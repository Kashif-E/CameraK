{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CameraK Documentation","text":"<p>Modern camera SDK for Kotlin Multiplatform \u2014 Android, iOS, and Desktop with a unified API.</p>"},{"location":"#get-started-in-60-seconds","title":"Get Started in 60 Seconds","text":"<pre><code>dependencies {\n    implementation(\"io.github.kashif-mehmood-km:camerak:0.2.0\")\n}\n</code></pre> <pre><code>@Composable\nfun CameraScreen() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val cameraState by rememberCameraKState(permissions = permissions).cameraState.collectAsStateWithLifecycle()\n\n    CameraKScreen(\n        cameraState = cameraState,\n        showPreview = true\n    ) { readyState -&gt;\n        // Camera preview shown automatically\n        FloatingActionButton(\n            onClick = { \n                scope.launch {\n                    readyState.controller.takePictureToFile()\n                }\n            }\n        ) {\n            Icon(Icons.Default.CameraAlt, \"Capture\")\n        }\n    }\n}\n</code></pre> <p>That's it! <code>CameraKScreen</code> handles all state management automatically.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Cross-Platform: Single API works on Android, iOS, and Desktop</li> <li>Compose-First: Built for Jetpack Compose with reactive StateFlow</li> <li>Plugin System: Add QR scanning, OCR, and custom processing</li> <li>Performance: Direct file capture avoids memory overhead</li> <li>Type-Safe: Sealed classes for errors, no runtime surprises</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Start with installation and configuration:</p> <ul> <li>Installation \u2014 Add CameraK to your project</li> <li>Quick Start \u2014 Build your first camera app in 5 minutes</li> <li>Configuration \u2014 Customize camera behavior</li> <li>Android Example \u2014 Android-specific setup</li> </ul>"},{"location":"#core-concepts","title":"Core Concepts","text":""},{"location":"#state-management","title":"State Management","text":"<p>CameraK uses reactive state management via <code>CameraKStateHolder</code>:</p> <pre><code>sealed class CameraKState {\n    object Initializing : CameraKState()\n    data class Ready(val controller: CameraController) : CameraKState()\n    data class Error(val exception: Exception) : CameraKState()\n}\n</code></pre> <p>State flows automatically: <code>Initializing</code> \u2192 <code>Ready</code> \u2192 capture photos.</p>"},{"location":"#camera-controller","title":"Camera Controller","text":"<p>Low-level camera operations exposed when state is <code>Ready</code>:</p> <pre><code>interface CameraController {\n    suspend fun takePictureToFile(): ImageCaptureResult\n    fun setZoom(zoom: Float)\n    fun setFlashMode(mode: FlashMode)\n    fun toggleCameraLens()\n}\n</code></pre>"},{"location":"#plugins","title":"Plugins","text":"<p>Extend camera functionality modularly:</p> <pre><code>val stateHolder = rememberCameraKState(\n    permissions = permissions,\n    plugins = listOf(\n        rememberQRScannerPlugin(),\n        rememberOcrPlugin()\n    )\n)\n\n// QR codes available automatically\nval qrCodes by stateHolder.qrCodeFlow.collectAsStateWithLifecycle()\n</code></pre>"},{"location":"#quick-links","title":"Quick Links","text":"<p>Getting Started - Installation - Quick Start - Configuration</p> <p>Guides - Camera Capture - Flash and Torch - Zoom Control - Camera Switching - Plugins</p> <p>API Reference - CameraKStateHolder - CameraController</p> <p>Plugins - Plugin System \u2014 Using and creating plugins</p>"},{"location":"#platform-requirements","title":"Platform Requirements","text":"Platform Minimum Version Backend Android API 21 (5.0) CameraX iOS 13.0 AVFoundation Desktop JDK 11+ JavaCV"},{"location":"#support","title":"Support","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Examples: Sample Projects</li> </ul>"},{"location":"#license","title":"License","text":"<p>Apache 2.0 \u2014 View License</p>"},{"location":"contributing/","title":"Contributing to CameraK","text":"<p>Thank you for your interest in contributing to CameraK! This document provides guidelines and steps for contributing.</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<ul> <li>\ud83d\udc1b Report Bugs \u2014 Found an issue? Let us know</li> <li>\ud83d\udca1 Suggest Features \u2014 Have an idea? Share it</li> <li>\ud83d\udcd6 Improve Documentation \u2014 Fix typos, add examples, clarify</li> <li>\ud83d\udd27 Submit Pull Requests \u2014 Fix bugs, add features</li> <li>\ud83d\udcac Help Others \u2014 Answer questions in Discussions</li> </ul>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>Before creating an issue, please:</p> <ol> <li>Search existing issues to avoid duplicates</li> <li>Use the issue template if available</li> <li>Provide details:</li> <li>CameraK version</li> <li>Platform (Android/iOS/Desktop) and OS version</li> <li>Device/emulator details</li> <li>Minimal reproducible example</li> <li>Expected vs actual behavior</li> <li>Stack trace/error messages</li> </ol>"},{"location":"contributing/#good-issue-example","title":"Good Issue Example","text":"<pre><code>**CameraK Version:** 0.2.0\n**Platform:** Android 13 (Pixel 6)\n\n**Description:**\nCamera preview shows black screen when using RATIO_1_1 aspect ratio.\n\n**Steps to Reproduce:**\n1. Configure camera with `setAspectRatio(AspectRatio.RATIO_1_1)`\n2. Launch camera screen\n3. Preview displays as black screen\n\n**Expected:** Square camera preview displays\n**Actual:** Black screen\n\n**Code:**\n```kotlin\nval stateHolder = rememberCameraKState(\n    permissions = permissions,\n    cameraConfiguration = {\n        setAspectRatio(AspectRatio.RATIO_1_1)\n    }\n)\n</code></pre> <p>Error Log: <pre><code>E/CameraK: Failed to bind camera...\n</code></pre> <pre><code>## Development Setup\n\n### Prerequisites\n\n- JDK 11+\n- Android Studio Hedgehog or later\n- Xcode 14+ (for iOS development)\n- Kotlin 1.9.0+\n\n### Clone Repository\n\n```bash\ngit clone https://github.com/Kashif-E/CameraK.git\ncd CameraK\n</code></pre></p>"},{"location":"contributing/#build-project","title":"Build Project","text":"<pre><code>./gradlew build\n</code></pre>"},{"location":"contributing/#run-sample-app","title":"Run Sample App","text":"<p>Android: <pre><code>./gradlew :Sample:installDebug\n</code></pre></p> <p>Desktop: <pre><code>./gradlew :Sample:run\n</code></pre></p> <p>iOS: <pre><code>cd iosApp\npod install\nopen iosApp.xcworkspace\n</code></pre></p>"},{"location":"contributing/#code-guidelines","title":"Code Guidelines","text":""},{"location":"contributing/#kotlin-style","title":"Kotlin Style","text":"<p>Follow Kotlin coding conventions:</p> <ul> <li>Use 4 spaces for indentation</li> <li>Use camelCase for functions and variables</li> <li>Use PascalCase for classes</li> <li>Maximum line length: 120 characters</li> </ul>"},{"location":"contributing/#naming-conventions","title":"Naming Conventions","text":"<p>Critical: Follow SDK naming rules</p> <ul> <li>Methods: <code>[Verb][Object]</code> pattern</li> <li>\u2705 <code>captureImage()</code>, <code>setZoom()</code>, <code>getFlashMode()</code></li> <li> <p>\u274c <code>imageCapturer()</code>, <code>zoomSet()</code>, <code>flashModeGet()</code></p> </li> <li> <p>Classes: Singular nouns</p> </li> <li>\u2705 <code>CameraController</code>, <code>ImageCaptureResult</code></li> <li> <p>\u274c <code>Controllers</code>, <code>ImageCaptureResults</code></p> </li> <li> <p>Packages: Domain-based</p> </li> <li>\u2705 <code>com.kashif.cameraK.controller</code></li> <li>\u274c <code>com.kashif.cameraK.utils</code></li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>All public APIs must have KDoc:</p> <pre><code>/**\n * Captures an image and saves it directly to a file.\n *\n * This method is significantly faster than takePicture() as it:\n * - Saves directly to disk without ByteArray conversion\n * - Skips decode/encode cycles (2-3 seconds faster)\n * - Avoids memory overhead from ByteArray processing\n *\n * @return ImageCaptureResult.SuccessWithFile containing the file path, or an error result\n *\n * @throws IOException if file cannot be written\n *\n * @example\n * ```kotlin\n * when (val result = controller.takePictureToFile()) {\n *     is ImageCaptureResult.SuccessWithFile -&gt; println(\"Saved: ${result.filePath}\")\n *     is ImageCaptureResult.Error -&gt; println(\"Error: ${result.exception.message}\")\n * }\n * ```\n */\nsuspend fun takePictureToFile(): ImageCaptureResult\n</code></pre>"},{"location":"contributing/#error-handling","title":"Error Handling","text":"<p>Use sealed classes for expected errors:</p> <pre><code>sealed class ImageCaptureResult {\n    data class SuccessWithFile(val filePath: String) : ImageCaptureResult()\n    data class Error(val exception: Exception) : ImageCaptureResult()\n}\n</code></pre> <p>Use specific exceptions for unexpected errors:</p> <pre><code>class CameraNotInitializedException(message: String) : Exception(message)\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Add tests for new features:</p> <pre><code>@Test\nfun `takePictureToFile returns success with file path`() = runTest {\n    val controller = createTestController()\n    val result = controller.takePictureToFile()\n\n    assertTrue(result is ImageCaptureResult.SuccessWithFile)\n    assertNotNull((result as ImageCaptureResult.SuccessWithFile).filePath)\n}\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"contributing/#1-fork-and-branch","title":"1. Fork and Branch","text":"<pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/your-bug-fix\n</code></pre>"},{"location":"contributing/#2-make-changes","title":"2. Make Changes","text":"<ul> <li>Write clear, focused commits</li> <li>Follow code guidelines</li> <li>Add tests for new features</li> <li>Update documentation</li> </ul>"},{"location":"contributing/#3-commit-messages","title":"3. Commit Messages","text":"<p>Use conventional commits:</p> <pre><code>feat: add pinch-to-zoom gesture support\nfix: resolve camera preview freeze on rotation\ndocs: update installation guide for iOS\ntest: add zoom control unit tests\nrefactor: simplify flash mode toggle logic\n</code></pre>"},{"location":"contributing/#4-push-and-create-pr","title":"4. Push and Create PR","text":"<pre><code>git push origin feature/your-feature-name\n</code></pre> <p>Create pull request on GitHub with:</p> <ul> <li>Title: Clear, concise description</li> <li>Description: </li> <li>What changed</li> <li>Why (reference issue if applicable)</li> <li>How to test</li> <li>Screenshots/videos if UI change</li> <li>Checklist:</li> <li>[ ] Code follows style guidelines</li> <li>[ ] Documentation updated</li> <li>[ ] Tests added/updated</li> <li>[ ] All tests pass</li> <li>[ ] No breaking changes (or documented)</li> </ul>"},{"location":"contributing/#5-code-review","title":"5. Code Review","text":"<ul> <li>Address reviewer feedback</li> <li>Keep discussion respectful</li> <li>Update PR as needed</li> </ul>"},{"location":"contributing/#6-merge","title":"6. Merge","text":"<p>Once approved, maintainers will merge your PR.</p>"},{"location":"contributing/#architecture-guidelines","title":"Architecture Guidelines","text":""},{"location":"contributing/#layer-1-platform-specific-expectactual","title":"Layer 1: Platform-Specific (expect/actual)","text":"<pre><code>// commonMain\nexpect class CameraController {\n    suspend fun takePictureToFile(): ImageCaptureResult\n}\n\n// androidMain\nactual class CameraController {\n    actual suspend fun takePictureToFile(): ImageCaptureResult {\n        // Android-specific CameraX implementation\n    }\n}\n</code></pre>"},{"location":"contributing/#layer-2-state-management","title":"Layer 2: State Management","text":"<pre><code>@Stable\nclass CameraKStateHolder(\n    private val controllerFactory: suspend () -&gt; CameraController,\n    private val coroutineScope: CoroutineScope\n) {\n    val cameraState: StateFlow&lt;CameraKState&gt;\n    val uiState: StateFlow&lt;CameraUIState&gt;\n}\n</code></pre>"},{"location":"contributing/#layer-3-compose-ui","title":"Layer 3: Compose UI","text":"<pre><code>@Composable\nfun rememberCameraKState(...): CameraKStateHolder\n</code></pre>"},{"location":"contributing/#breaking-changes","title":"Breaking Changes","text":"<p>Avoid breaking changes when possible. If necessary:</p> <ol> <li>Deprecate first (12-month timeline)</li> <li>Provide migration path</li> <li>Document in CHANGELOG</li> <li>Bump major version</li> </ol> <pre><code>@Deprecated(\n    message = \"Use takePictureToFile() instead\",\n    replaceWith = ReplaceWith(\"takePictureToFile()\"),\n    level = DeprecationLevel.WARNING  // v1.x\n)\nsuspend fun takePicture(): ImageCaptureResult\n</code></pre>"},{"location":"contributing/#documentation-changes","title":"Documentation Changes","text":"<p>Update documentation in <code>docs/</code>:</p> <ul> <li><code>getting-started/</code> \u2014 Installation, quick start, configuration</li> <li><code>guides/</code> \u2014 Feature-specific guides</li> <li><code>api/</code> \u2014 API reference</li> <li><code>examples/</code> \u2014 Platform-specific examples</li> </ul> <p>Use Stripe-style documentation: - Clear, concise examples - Real, working code - Copy-paste ready - Progressive disclosure (simple \u2192 advanced)</p>"},{"location":"contributing/#community-guidelines","title":"Community Guidelines","text":"<ul> <li>Be respectful and inclusive</li> <li>Help others learn</li> <li>Provide constructive feedback</li> <li>Follow the Code of Conduct</li> </ul>"},{"location":"contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in: - GitHub contributors page - Release notes (for significant contributions) - CHANGELOG (for bug fixes and features)</p>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>GitHub Discussions: Discussions</li> <li>Issues: Issues</li> </ul>"},{"location":"contributing/#thank-you","title":"Thank You!","text":"<p>Your contributions make CameraK better for everyone. We appreciate your time and effort! \ud83d\ude4f</p>"},{"location":"license/","title":"License","text":"<p>CameraK is licensed under the Apache License 2.0.</p> <pre><code>Copyright 2024 Kashif Mehmood\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"license/#what-this-means","title":"What This Means","text":""},{"location":"license/#you-can","title":"You CAN:","text":"<ul> <li>\u2705 Use CameraK in commercial projects</li> <li>\u2705 Modify the source code</li> <li>\u2705 Distribute modified versions</li> <li>\u2705 Include CameraK in proprietary software</li> <li>\u2705 Use CameraK for private projects</li> </ul>"},{"location":"license/#you-must","title":"You MUST:","text":"<ul> <li>\ud83d\udcc4 Include a copy of the Apache 2.0 license</li> <li>\ud83d\udcc4 State significant changes made to the code</li> <li>\ud83d\udcc4 Include copyright notices</li> </ul>"},{"location":"license/#you-cannot","title":"You CANNOT:","text":"<ul> <li>\u274c Hold the author liable for damages</li> <li>\u274c Use CameraK trademarks without permission</li> <li>\u274c Claim you wrote the original code</li> </ul>"},{"location":"license/#third-party-licenses","title":"Third-Party Licenses","text":"<p>CameraK uses the following open-source libraries:</p>"},{"location":"license/#android","title":"Android","text":"<ul> <li>CameraX \u2014 Apache 2.0</li> <li>Kotlin \u2014 Apache 2.0</li> </ul>"},{"location":"license/#ios","title":"iOS","text":"<ul> <li>AVFoundation \u2014 Apple SDK License</li> </ul>"},{"location":"license/#desktop","title":"Desktop","text":"<ul> <li>JavaCV \u2014 Apache 2.0 / GPL 2.0 (with Classpath exception)</li> </ul>"},{"location":"license/#full-license-text","title":"Full License Text","text":"<p>The full Apache License 2.0 text is available at: https://www.apache.org/licenses/LICENSE-2.0</p>"},{"location":"license/#questions","title":"Questions?","text":"<p>For licensing questions, contact: - GitHub: @Kashif-E - Issues: github.com/Kashif-E/CameraK/issues</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and solutions for CameraK.</p>"},{"location":"troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"troubleshooting/#could-not-find-iogithubkashif-mehmood-kmcamerak","title":"\"Could not find io.github.kashif-mehmood-km:camerak\"","text":"<p>Cause: Repository not configured.</p> <p>Solution: Ensure Maven Central is in repositories:</p> <pre><code>repositories {\n    mavenCentral()\n}\n</code></pre>"},{"location":"troubleshooting/#gradle-sync-failed","title":"Gradle Sync Failed","text":"<p>Cause: Version conflict or network issue.</p> <p>Solution: 1. Check internet connection 2. Invalidate caches: <code>File</code> \u2192 <code>Invalidate Caches / Restart</code> 3. Clean build: <code>./gradlew clean build</code></p>"},{"location":"troubleshooting/#permission-issues","title":"Permission Issues","text":""},{"location":"troubleshooting/#camera-permission-denied-android","title":"\"Camera permission denied\" (Android)","text":"<p>Cause: User denied camera permission.</p> <p>Solution: Request permission in manifest and code:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt;\n</code></pre> <pre><code>val cameraPermission = rememberPermissionState(android.Manifest.permission.CAMERA)\nLaunchedEffect(Unit) {\n    if (!cameraPermission.status.isGranted) {\n        cameraPermission.launchPermissionRequest()\n    }\n}\n</code></pre>"},{"location":"troubleshooting/#camera-access-requires-nscamerausagedescription-ios","title":"\"Camera access requires NSCameraUsageDescription\" (iOS)","text":"<p>Cause: Missing usage description in Info.plist.</p> <p>Solution: Add to Info.plist:</p> <pre><code>&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;\n&lt;string&gt;Camera access required for taking photos&lt;/string&gt;\n</code></pre>"},{"location":"troubleshooting/#camera-not-working","title":"Camera Not Working","text":""},{"location":"troubleshooting/#camera-not-available","title":"\"Camera not available\"","text":"<p>Cause: Device has no camera or emulator misconfigured.</p> <p>Solution: - Physical device: Ensure camera hardware exists - Emulator: Configure camera in AVD settings - Desktop: Connect webcam</p>"},{"location":"troubleshooting/#camera-preview-black-screen","title":"Camera Preview Black Screen","text":"<p>Cause: Camera not initialized or permission denied.</p> <p>Solution: 1. Check camera state is <code>Ready</code> 2. Verify permissions granted 3. Restart app</p> <pre><code>when (cameraState) {\n    is CameraKState.Ready -&gt; {\n        // Camera operational\n    }\n    is CameraKState.Error -&gt; {\n        println(\"Error: ${(cameraState as CameraKState.Error).exception.message}\")\n    }\n}\n</code></pre>"},{"location":"troubleshooting/#preview-frozen","title":"Preview Frozen","text":"<p>Cause: Camera session stopped.</p> <p>Solution: Restart camera session:</p> <pre><code>DisposableEffect(Unit) {\n    controller.startSession()\n    onDispose {\n        controller.stopSession()\n    }\n}\n</code></pre>"},{"location":"troubleshooting/#capture-issues","title":"Capture Issues","text":""},{"location":"troubleshooting/#capture-failed-camera-not-initialized","title":"\"Capture failed: Camera not initialized\"","text":"<p>Cause: Attempting capture before camera ready.</p> <p>Solution: Only capture when state is <code>Ready</code>:</p> <pre><code>when (cameraState) {\n    is CameraKState.Ready -&gt; {\n        val controller = (cameraState as CameraKState.Ready).controller\n        Button(onClick = {\n            scope.launch {\n                controller.takePictureToFile()\n            }\n        }) {\n            Text(\"Capture\")\n        }\n    }\n}\n</code></pre>"},{"location":"troubleshooting/#storage-permission-denied-android-10","title":"\"Storage permission denied\" (Android &lt; 10)","text":"<p>Cause: Missing WRITE_EXTERNAL_STORAGE permission.</p> <p>Solution: Add to manifest:</p> <pre><code>&lt;uses-permission \n    android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"\n    android:maxSdkVersion=\"28\" /&gt;\n</code></pre>"},{"location":"troubleshooting/#images-not-saving","title":"Images Not Saving","text":"<p>Cause: Invalid directory or storage full.</p> <p>Solution: 1. Check storage space 2. Use valid directory:</p> <pre><code>cameraConfiguration = {\n    setDirectory(Directory.PICTURES)  // or DCIM, DOWNLOADS, etc.\n}\n</code></pre>"},{"location":"troubleshooting/#poor-image-quality","title":"Poor Image Quality","text":"<p>Cause: Low quality prioritization or resolution.</p> <p>Solution: Configure for quality:</p> <pre><code>cameraConfiguration = {\n    setQualityPrioritization(QualityPrioritization.QUALITY)\n    setResolution(3840 to 2160)  // 4K\n    setImageFormat(ImageFormat.PNG)  // Lossless\n}\n</code></pre>"},{"location":"troubleshooting/#flashtorch-issues","title":"Flash/Torch Issues","text":""},{"location":"troubleshooting/#flash-not-working","title":"Flash Not Working","text":"<p>Cause: Front camera selected (no flash) or device doesn't support flash.</p> <p>Solution: Switch to rear camera:</p> <pre><code>controller.setCameraLens(CameraLens.BACK)\ncontroller.setFlashMode(FlashMode.ON)\n</code></pre>"},{"location":"troubleshooting/#torch-stays-on-after-closing-app","title":"Torch Stays On After Closing App","text":"<p>Cause: Torch not disabled in cleanup.</p> <p>Solution: Disable in cleanup:</p> <pre><code>DisposableEffect(Unit) {\n    onDispose {\n        controller.setTorchMode(TorchMode.OFF)\n        controller.cleanup()\n    }\n}\n</code></pre>"},{"location":"troubleshooting/#zoom-issues","title":"Zoom Issues","text":""},{"location":"troubleshooting/#zoom-not-working","title":"Zoom Not Working","text":"<p>Cause: Camera doesn't support zoom or at max zoom.</p> <p>Solution: Check zoom support:</p> <pre><code>val maxZoom = controller.getMaxZoom()\nif (maxZoom &gt; 1.0f) {\n    controller.setZoom(2.0f)\n} else {\n    println(\"Zoom not supported\")\n}\n</code></pre>"},{"location":"troubleshooting/#zoom-resets-when-switching-cameras","title":"Zoom Resets When Switching Cameras","text":"<p>Cause: Each camera has independent zoom settings.</p> <p>Solution: Re-apply zoom after switch:</p> <pre><code>val savedZoom = controller.getZoom()\ncontroller.toggleCameraLens()\ndelay(200)\ncontroller.setZoom(savedZoom.coerceIn(1f, controller.getMaxZoom()))\n</code></pre>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#slow-capture","title":"Slow Capture","text":"<p>Cause: Using deprecated <code>takePicture()</code> instead of <code>takePictureToFile()</code>.</p> <p>Solution: Use recommended method:</p> <pre><code>// \u274c Slow (deprecated)\nval result = controller.takePicture()\n\n// \u2705 Fast (recommended)\nval result = controller.takePictureToFile()\n</code></pre>"},{"location":"troubleshooting/#app-crashes-on-capture","title":"App Crashes on Capture","text":"<p>Cause: Out of memory or too many concurrent captures.</p> <p>Solution: 1. Limit burst captures to 3-5 photos 2. Use lower resolution 3. Use <code>takePictureToFile()</code> instead of <code>takePicture()</code></p> <pre><code>cameraConfiguration = {\n    setResolution(1920 to 1080)  // Lower resolution\n}\n</code></pre>"},{"location":"troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<p>Cause: Multiple plugins or high-resolution processing.</p> <p>Solution: 1. Reduce plugin count 2. Lower resolution 3. Use <code>ImageFormat.JPEG</code> instead of PNG</p>"},{"location":"troubleshooting/#plugin-issues","title":"Plugin Issues","text":""},{"location":"troubleshooting/#qr-scanner-not-detecting-codes","title":"QR Scanner Not Detecting Codes","text":"<p>Cause: Poor lighting or QR code quality.</p> <p>Solution: 1. Enable torch for better lighting 2. Ensure QR code is clear and unobstructed 3. Move camera closer to QR code</p>"},{"location":"troubleshooting/#ocr-not-recognizing-text","title":"OCR Not Recognizing Text","text":"<p>Cause: Text too small, blurry, or language not supported.</p> <p>Solution: 1. Move camera closer 2. Ensure good lighting 3. Hold camera steady (avoid motion blur)</p>"},{"location":"troubleshooting/#plugin-not-activating","title":"Plugin Not Activating","text":"<p>Cause: Plugin added after camera already ready.</p> <p>Solution: Add plugins during initialization:</p> <pre><code>val stateHolder = rememberCameraKState(\n    permissions = permissions,\n    plugins = listOf(\n        rememberQRScannerPlugin(),\n        rememberOcrPlugin()\n    )\n)\n</code></pre>"},{"location":"troubleshooting/#platform-specific-issues","title":"Platform-Specific Issues","text":""},{"location":"troubleshooting/#android","title":"Android","text":"<p>Issue: \"CameraX binding failed\"</p> <p>Solution: Ensure minSdk is 21+:</p> <pre><code>android {\n    defaultConfig {\n        minSdk = 21\n    }\n}\n</code></pre> <p>Issue: \"No suitable camera found\"</p> <p>Solution: Check device has both front and back cameras, or handle gracefully:</p> <pre><code>val lens = controller.getCameraLens()\nif (lens == null) {\n    println(\"Camera not available\")\n}\n</code></pre>"},{"location":"troubleshooting/#ios","title":"iOS","text":"<p>Issue: \"Camera preview upside down\"</p> <p>Solution: Device orientation handling. CameraK handles this automatically - report if issue persists.</p> <p>Issue: \"Camera types not available (TELEPHOTO, ULTRA_WIDE)\"</p> <p>Solution: These features require specific iPhone models: - Ultra-wide: iPhone 11+ - Telephoto: iPhone 7 Plus+</p> <p>Check availability:</p> <pre><code>cameraConfiguration = {\n    setCameraDeviceType(CameraDeviceType.ULTRA_WIDE)\n}\n// Falls back to DEFAULT if not available\n</code></pre>"},{"location":"troubleshooting/#desktop","title":"Desktop","text":"<p>Issue: \"No webcam detected\"</p> <p>Solution: Ensure webcam is: 1. Connected to computer 2. Not in use by another application 3. Drivers installed</p> <p>Issue: Flash/torch not working</p> <p>Cause: Desktop webcams don't have flash hardware.</p> <p>Solution: Use external lighting.</p>"},{"location":"troubleshooting/#build-issues","title":"Build Issues","text":""},{"location":"troubleshooting/#duplicate-class-error","title":"\"Duplicate class\" Error","text":"<p>Cause: Conflicting dependencies.</p> <p>Solution: Check for duplicate libraries:</p> <pre><code>./gradlew :app:dependencies\n</code></pre> <p>Remove conflicting CameraX or Kotlin versions.</p>"},{"location":"troubleshooting/#ios-build-fails","title":"iOS Build Fails","text":"<p>Cause: Cocoapods not configured.</p> <p>Solution: Run in iOS project:</p> <pre><code>cd iosApp\npod install\n</code></pre>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still stuck:</p> <ol> <li>Check Examples: Sample Projects</li> <li>Search Issues: GitHub Issues</li> <li>Ask Questions: GitHub Discussions</li> <li>Report Bugs: New Issue</li> </ol>"},{"location":"troubleshooting/#when-reporting-issues","title":"When Reporting Issues","text":"<p>Include: - CameraK version - Platform (Android/iOS/Desktop) - Device/emulator details - Minimal reproducible code - Stack trace/error messages - Expected vs actual behavior</p> <p>Good issue: <pre><code>CameraK 0.2.0\nAndroid 13 (Pixel 6)\n\nPreview shows black screen when using:\n```kotlin\nval stateHolder = rememberCameraKState(...)\n</code></pre></p> <p>Error: \"Camera not available\"</p> <p>Expected: Camera preview displays ```</p>"},{"location":"troubleshooting/#known-limitations","title":"Known Limitations","text":"<ol> <li>Desktop: Limited flash/torch support (hardware limitation)</li> <li>iOS Simulator: Camera not available (use real device)</li> <li>Android Emulator: Limited camera features (use real device for testing)</li> <li>Burst Capture: Max 3 concurrent captures (prevents memory issues)</li> </ol>"},{"location":"troubleshooting/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start \u2014 Get started quickly</li> <li>Configuration \u2014 Customize behavior</li> <li>API Reference \u2014 Full API documentation</li> </ul>"},{"location":"api/camera-k-screen/","title":"CameraKScreen","text":"<p>Convenience wrapper composable that simplifies camera state handling with automatic preview management.</p>"},{"location":"api/camera-k-screen/#overview","title":"Overview","text":"<p><code>CameraKScreen</code> is a slot-based composable that handles camera state (Initializing/Ready/Error) automatically, showing appropriate UI for each state with sensible defaults.</p> <p>Benefits: - \u2705 Automatic state handling (no when expression needed) - \u2705 Built-in loading and error screens - \u2705 Camera preview shown automatically (optional) - \u2705 Slot-based API for custom content - \u2705 Less boilerplate than manual state handling</p>"},{"location":"api/camera-k-screen/#function-signature","title":"Function Signature","text":"<pre><code>@Composable\nfun CameraKScreen(\n    modifier: Modifier = Modifier,\n    cameraState: CameraKState,\n    loadingContent: @Composable () -&gt; Unit = { DefaultLoadingScreen() },\n    errorContent: @Composable (CameraKState.Error) -&gt; Unit = { DefaultErrorScreen(it) },\n    showPreview: Boolean = true,\n    content: @Composable (CameraKState.Ready) -&gt; Unit\n)\n</code></pre>"},{"location":"api/camera-k-screen/#parameters","title":"Parameters","text":""},{"location":"api/camera-k-screen/#camerastate","title":"cameraState","text":"<pre><code>cameraState: CameraKState\n</code></pre> <p>Camera state from <code>rememberCameraKState().cameraState</code>. Can be one of: - <code>CameraKState.Initializing</code> \u2014 Camera starting - <code>CameraKState.Ready</code> \u2014 Camera operational - <code>CameraKState.Error</code> \u2014 Initialization failed</p>"},{"location":"api/camera-k-screen/#showpreview","title":"showPreview","text":"<pre><code>showPreview: Boolean = true\n</code></pre> <p>Whether to automatically show camera preview when ready. </p> <ul> <li><code>true</code> (default) \u2014 Preview shown automatically in background</li> <li><code>false</code> \u2014 No preview, useful for custom preview implementations</li> </ul>"},{"location":"api/camera-k-screen/#loadingcontent","title":"loadingContent","text":"<pre><code>loadingContent: @Composable () -&gt; Unit = { DefaultLoadingScreen() }\n</code></pre> <p>Content shown during camera initialization. Default shows loading spinner with \"Initializing Camera...\" text.</p> <p>Custom example:</p> <pre><code>loadingContent = {\n    Column(\n        modifier = Modifier.fillMaxSize(),\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        CircularProgressIndicator()\n        Spacer(modifier = Modifier.height(16.dp))\n        Text(\"Starting camera...\")\n    }\n}\n</code></pre>"},{"location":"api/camera-k-screen/#errorcontent","title":"errorContent","text":"<pre><code>errorContent: @Composable (CameraKState.Error) -&gt; Unit = { DefaultErrorScreen(it) }\n</code></pre> <p>Content shown on camera error. Receives <code>CameraKState.Error</code> with exception details.</p> <p>Custom example:</p> <pre><code>errorContent = { error -&gt;\n    Column(\n        modifier = Modifier.fillMaxSize(),\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Icon(Icons.Default.Error, \"Error\", tint = Color.Red)\n        Text(\"Camera Error: ${error.message}\")\n        Button(onClick = { /* retry logic */ }) {\n            Text(\"Retry\")\n        }\n    }\n}\n</code></pre>"},{"location":"api/camera-k-screen/#content","title":"content","text":"<pre><code>content: @Composable (CameraKState.Ready) -&gt; Unit\n</code></pre> <p>Main content shown when camera is ready. Receives <code>CameraKState.Ready</code> with access to: - <code>readyState.controller</code> \u2014 Camera controller for operations - <code>readyState.uiState</code> \u2014 Observable UI state</p> <p>This is where you add your camera controls.</p>"},{"location":"api/camera-k-screen/#basic-example","title":"Basic Example","text":"<pre><code>@Composable\nfun SimpleCameraApp() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val cameraState by rememberCameraKState(permissions = permissions).cameraState.collectAsStateWithLifecycle()\n\n    CameraKScreen(\n        cameraState = cameraState\n    ) { readyState -&gt;\n        // Camera preview shown automatically\n        // Add controls overlay\n        FloatingActionButton(\n            onClick = {\n                scope.launch {\n                    readyState.controller.takePictureToFile()\n                }\n            },\n            modifier = Modifier\n                .fillMaxSize()\n                .wrapContentSize(Alignment.BottomCenter)\n                .padding(32.dp)\n        ) {\n            Icon(Icons.Default.CameraAlt, \"Capture\")\n        }\n    }\n}\n</code></pre>"},{"location":"api/camera-k-screen/#custom-loadingerror-screens","title":"Custom Loading/Error Screens","text":"<pre><code>@Composable\nfun CameraWithCustomScreens() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val cameraState by rememberCameraKState(permissions = permissions).cameraState.collectAsStateWithLifecycle()\n\n    CameraKScreen(\n        cameraState = cameraState,\n        loadingContent = {\n            Box(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .background(MaterialTheme.colorScheme.surface),\n                contentAlignment = Alignment.Center\n            ) {\n                Column(\n                    horizontalAlignment = Alignment.CenterHorizontally,\n                    verticalArrangement = Arrangement.spacedBy(16.dp)\n                ) {\n                    CircularProgressIndicator()\n                    Text(\n                        \"Preparing camera...\",\n                        style = MaterialTheme.typography.bodyLarge\n                    )\n                }\n            }\n        },\n        errorContent = { error -&gt;\n            Box(\n                modifier = Modifier.fillMaxSize(),\n                contentAlignment = Alignment.Center\n            ) {\n                Column(\n                    horizontalAlignment = Alignment.CenterHorizontally,\n                    verticalArrangement = Arrangement.spacedBy(16.dp),\n                    modifier = Modifier.padding(32.dp)\n                ) {\n                    Icon(\n                        Icons.Default.Error,\n                        contentDescription = \"Error\",\n                        tint = MaterialTheme.colorScheme.error,\n                        modifier = Modifier.size(48.dp)\n                    )\n                    Text(\n                        \"Unable to start camera\",\n                        style = MaterialTheme.typography.titleLarge\n                    )\n                    Text(\n                        error.message,\n                        style = MaterialTheme.typography.bodyMedium,\n                        textAlign = TextAlign.Center\n                    )\n                    if (error.isRetryable) {\n                        Button(onClick = { /* retry */ }) {\n                            Text(\"Try Again\")\n                        }\n                    }\n                }\n            }\n        }\n    ) { readyState -&gt;\n        // Camera controls\n        CameraControls(controller = readyState.controller)\n    }\n}\n</code></pre>"},{"location":"api/camera-k-screen/#no-auto-preview-mode","title":"No Auto-Preview Mode","text":"<p>Disable automatic preview for custom implementations:</p> <pre><code>@Composable\nfun CustomPreviewCamera() {\n    val permissions = providePermissions()\n    val cameraState by rememberCameraKState(permissions = permissions).cameraState.collectAsStateWithLifecycle()\n\n    CameraKScreen(\n        cameraState = cameraState,\n        showPreview = false  // Disable automatic preview\n    ) { readyState -&gt;\n        // Implement custom preview\n        Box(modifier = Modifier.fillMaxSize()) {\n            // Custom camera preview with filters/effects\n            CustomCameraPreviewWithFilters(controller = readyState.controller)\n\n            // Controls overlay\n            CameraControls(\n                controller = readyState.controller,\n                modifier = Modifier.align(Alignment.BottomCenter)\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"api/camera-k-screen/#with-plugins","title":"With Plugins","text":"<pre><code>@Composable\nfun CameraWithPlugins() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(\n        permissions = permissions,\n        plugins = listOf(\n            rememberQRScannerPlugin(),\n            rememberOcrPlugin()\n        )\n    )\n\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    val qrCodes by stateHolder.qrCodeFlow.collectAsStateWithLifecycle(initial = emptyList())\n    val recognizedText by stateHolder.recognizedTextFlow.collectAsStateWithLifecycle(initial = \"\")\n\n    CameraKScreen(cameraState = cameraState) { readyState -&gt;\n        Box(modifier = Modifier.fillMaxSize()) {\n            // QR code display\n            if (qrCodes.isNotEmpty()) {\n                Card(\n                    modifier = Modifier\n                        .align(Alignment.TopCenter)\n                        .padding(16.dp)\n                ) {\n                    Text(\n                        text = \"QR: ${qrCodes.last()}\",\n                        modifier = Modifier.padding(16.dp)\n                    )\n                }\n            }\n\n            // OCR text display\n            if (recognizedText.isNotEmpty()) {\n                Card(\n                    modifier = Modifier\n                        .align(Alignment.TopStart)\n                        .padding(16.dp)\n                ) {\n                    Text(\n                        text = \"OCR: $recognizedText\",\n                        modifier = Modifier.padding(16.dp)\n                    )\n                }\n            }\n\n            // Capture button\n            FloatingActionButton(\n                onClick = {\n                    scope.launch {\n                        readyState.controller.takePictureToFile()\n                    }\n                },\n                modifier = Modifier\n                    .align(Alignment.BottomCenter)\n                    .padding(32.dp)\n            ) {\n                Icon(Icons.Default.CameraAlt, \"Capture\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"api/camera-k-screen/#complete-camera-app","title":"Complete Camera App","text":"<p>Full-featured camera with all controls:</p> <pre><code>@Composable\nfun FullFeaturedCamera() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(\n        permissions = permissions,\n        cameraConfiguration = {\n            setCameraLens(CameraLens.BACK)\n            setFlashMode(FlashMode.AUTO)\n            setAspectRatio(AspectRatio.RATIO_16_9)\n        }\n    )\n\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    val uiState by stateHolder.uiState.collectAsStateWithLifecycle()\n\n    CameraKScreen(cameraState = cameraState) { readyState -&gt;\n        Box(modifier = Modifier.fillMaxSize()) {\n            // Top controls\n            Row(\n                modifier = Modifier\n                    .align(Alignment.TopEnd)\n                    .padding(16.dp),\n                horizontalArrangement = Arrangement.spacedBy(8.dp)\n            ) {\n                // Flash toggle\n                IconButton(onClick = { readyState.controller.toggleFlashMode() }) {\n                    Icon(\n                        when (uiState.flashMode) {\n                            FlashMode.ON -&gt; Icons.Default.FlashOn\n                            FlashMode.OFF -&gt; Icons.Default.FlashOff\n                            FlashMode.AUTO -&gt; Icons.Default.FlashAuto\n                        },\n                        \"Flash\"\n                    )\n                }\n\n                // Camera switch\n                IconButton(onClick = { readyState.controller.toggleCameraLens() }) {\n                    Icon(Icons.Default.Cameraswitch, \"Switch Camera\")\n                }\n            }\n\n            // Zoom indicator\n            if (uiState.zoomLevel &gt; 1.0f) {\n                Text(\n                    text = \"${String.format(\"%.1f\", uiState.zoomLevel)}x\",\n                    modifier = Modifier\n                        .align(Alignment.TopCenter)\n                        .padding(16.dp)\n                        .background(Color.Black.copy(alpha = 0.5f), RoundedCornerShape(16.dp))\n                        .padding(horizontal = 16.dp, vertical = 8.dp),\n                    color = Color.White\n                )\n            }\n\n            // Pinch to zoom\n            val maxZoom = uiState.maxZoom\n            Box(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .pointerInput(Unit) {\n                        detectTransformGestures { _, _, zoom, _ -&gt;\n                            val newZoom = (uiState.zoomLevel * zoom).coerceIn(1f, maxZoom)\n                            readyState.controller.setZoom(newZoom)\n                        }\n                    }\n            )\n\n            // Capture button\n            FloatingActionButton(\n                onClick = {\n                    scope.launch {\n                        when (val result = readyState.controller.takePictureToFile()) {\n                            is ImageCaptureResult.SuccessWithFile -&gt; {\n                                // Show success toast\n                            }\n                            is ImageCaptureResult.Error -&gt; {\n                                // Show error\n                            }\n                        }\n                    }\n                },\n                modifier = Modifier\n                    .align(Alignment.BottomCenter)\n                    .padding(32.dp)\n            ) {\n                if (uiState.isCapturing) {\n                    CircularProgressIndicator(\n                        color = Color.White,\n                        modifier = Modifier.size(24.dp)\n                    )\n                } else {\n                    Icon(Icons.Default.CameraAlt, \"Capture\")\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"api/camera-k-screen/#comparison-manual-vs-camerakscreen","title":"Comparison: Manual vs CameraKScreen","text":""},{"location":"api/camera-k-screen/#manual-state-handling","title":"Manual State Handling","text":"<pre><code>@Composable\nfun ManualApproach() {\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n\n    when (cameraState) {\n        CameraKState.Initializing -&gt; {\n            CircularProgressIndicator()\n        }\n        is CameraKState.Ready -&gt; {\n            val controller = (cameraState as CameraKState.Ready).controller\n            CameraPreviewComposable(controller = controller)\n            // Your UI here\n        }\n        is CameraKState.Error -&gt; {\n            Text(\"Error: ${(cameraState as CameraKState.Error).message}\")\n        }\n    }\n}\n</code></pre>"},{"location":"api/camera-k-screen/#using-camerakscreen","title":"Using CameraKScreen","text":"<pre><code>@Composable\nfun WithCameraKScreen() {\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n\n    CameraKScreen(cameraState = cameraState) { readyState -&gt;\n        // Your UI here - loading/error/preview handled automatically\n    }\n}\n</code></pre> <p>Result: 60% less boilerplate, same functionality.</p>"},{"location":"api/camera-k-screen/#default-screens","title":"Default Screens","text":""},{"location":"api/camera-k-screen/#defaultloadingscreen","title":"DefaultLoadingScreen","text":"<p>Shows: - Black background - White circular progress indicator - \"Initializing Camera...\" text</p>"},{"location":"api/camera-k-screen/#defaulterrorscreen","title":"DefaultErrorScreen","text":"<p>Shows: - Black background - \"Camera Error\" title in red - Error message in white - \"Please try again\" hint (if retryable)</p> <p>Override these by passing custom <code>loadingContent</code> and <code>errorContent</code>.</p>"},{"location":"api/camera-k-screen/#see-also","title":"See Also","text":"<ul> <li>CameraKStateHolder \u2014 State management</li> <li>CameraController \u2014 Camera operations</li> <li>Quick Start \u2014 Usage examples</li> </ul>"},{"location":"api/controller/","title":"CameraController API","text":"<p>Low-level camera operations. Available when camera state is <code>Ready</code>.</p>"},{"location":"api/controller/#accessing-controller","title":"Accessing Controller","text":"<pre><code>val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n\nwhen (cameraState) {\n    is CameraKState.Ready -&gt; {\n        val controller = (cameraState as CameraKState.Ready).controller\n        // Use controller here\n    }\n}\n</code></pre>"},{"location":"api/controller/#image-capture","title":"Image Capture","text":""},{"location":"api/controller/#takepicturetofile","title":"takePictureToFile()","text":"<p>Recommended \u2014 Captures image directly to file.</p> <pre><code>suspend fun takePictureToFile(): ImageCaptureResult\n</code></pre> <p>Returns: - <code>ImageCaptureResult.SuccessWithFile(filePath: String)</code> - <code>ImageCaptureResult.Error(exception: Exception)</code></p> <p>Example:</p> <pre><code>scope.launch {\n    when (val result = controller.takePictureToFile()) {\n        is ImageCaptureResult.SuccessWithFile -&gt; {\n            println(\"Saved: ${result.filePath}\")\n        }\n        is ImageCaptureResult.Error -&gt; {\n            println(\"Error: ${result.exception.message}\")\n        }\n    }\n}\n</code></pre> <p>Benefits: - 2-3 seconds faster than <code>takePicture()</code> - No ByteArray conversion - Lower memory usage</p>"},{"location":"api/controller/#takepicture","title":"takePicture()","text":"<p>Deprecated \u2014 Returns image as ByteArray.</p> <pre><code>@Deprecated(\"Use takePictureToFile()\")\nsuspend fun takePicture(): ImageCaptureResult\n</code></pre> <p>Returns: - <code>ImageCaptureResult.Success(byteArray: ByteArray)</code> - <code>ImageCaptureResult.Error(exception: Exception)</code></p>"},{"location":"api/controller/#zoom-control","title":"Zoom Control","text":""},{"location":"api/controller/#setzoom","title":"setZoom()","text":"<pre><code>fun setZoom(zoomRatio: Float)\n</code></pre> <p>Sets zoom level between 1.0 and maxZoom.</p> <p>Parameters: - <code>zoomRatio</code> \u2014 Zoom level (1.0 = no zoom)</p> <p>Example:</p> <pre><code>controller.setZoom(2.5f)  // 2.5x zoom\n</code></pre>"},{"location":"api/controller/#getzoom","title":"getZoom()","text":"<pre><code>fun getZoom(): Float\n</code></pre> <p>Returns current zoom level.</p> <p>Example:</p> <pre><code>val currentZoom = controller.getZoom()  // e.g., 2.5\n</code></pre>"},{"location":"api/controller/#getmaxzoom","title":"getMaxZoom()","text":"<pre><code>fun getMaxZoom(): Float\n</code></pre> <p>Returns maximum supported zoom.</p> <p>Example:</p> <pre><code>val maxZoom = controller.getMaxZoom()  // e.g., 10.0\n</code></pre>"},{"location":"api/controller/#flash-control","title":"Flash Control","text":""},{"location":"api/controller/#setflashmode","title":"setFlashMode()","text":"<pre><code>fun setFlashMode(mode: FlashMode)\n</code></pre> <p>Sets flash mode.</p> <p>Parameters: - <code>FlashMode.ON</code> \u2014 Always fire flash - <code>FlashMode.OFF</code> \u2014 Flash disabled - <code>FlashMode.AUTO</code> \u2014 Flash in low light</p> <p>Example:</p> <pre><code>controller.setFlashMode(FlashMode.ON)\n</code></pre>"},{"location":"api/controller/#getflashmode","title":"getFlashMode()","text":"<pre><code>fun getFlashMode(): FlashMode?\n</code></pre> <p>Returns current flash mode or <code>null</code> if not available.</p> <p>Example:</p> <pre><code>val flashMode = controller.getFlashMode()\nwhen (flashMode) {\n    FlashMode.ON -&gt; println(\"Flash enabled\")\n    FlashMode.OFF -&gt; println(\"Flash disabled\")\n    FlashMode.AUTO -&gt; println(\"Flash automatic\")\n    null -&gt; println(\"Flash not available\")\n}\n</code></pre>"},{"location":"api/controller/#toggleflashmode","title":"toggleFlashMode()","text":"<pre><code>fun toggleFlashMode()\n</code></pre> <p>Cycles through: OFF \u2192 ON \u2192 AUTO \u2192 OFF</p> <p>Example:</p> <pre><code>IconButton(onClick = { controller.toggleFlashMode() }) {\n    Icon(Icons.Default.FlashOn, \"Toggle Flash\")\n}\n</code></pre>"},{"location":"api/controller/#torch-control","title":"Torch Control","text":""},{"location":"api/controller/#settorchmode","title":"setTorchMode()","text":"<pre><code>fun setTorchMode(mode: TorchMode)\n</code></pre> <p>Sets torch (flashlight) mode.</p> <p>Parameters: - <code>TorchMode.ON</code> \u2014 Torch enabled - <code>TorchMode.OFF</code> \u2014 Torch disabled</p> <p>Example:</p> <pre><code>controller.setTorchMode(TorchMode.ON)\n</code></pre>"},{"location":"api/controller/#gettorchmode","title":"getTorchMode()","text":"<pre><code>fun getTorchMode(): TorchMode?\n</code></pre> <p>Returns current torch mode or <code>null</code> if not available.</p>"},{"location":"api/controller/#toggletorchmode","title":"toggleTorchMode()","text":"<pre><code>fun toggleTorchMode()\n</code></pre> <p>Toggles torch ON \u2194 OFF.</p> <p>Example:</p> <pre><code>IconButton(onClick = { controller.toggleTorchMode() }) {\n    val isOn = controller.getTorchMode() == TorchMode.ON\n    Icon(\n        if (isOn) Icons.Default.FlashlightOn else Icons.Default.FlashlightOff,\n        \"Toggle Torch\"\n    )\n}\n</code></pre>"},{"location":"api/controller/#camera-lens","title":"Camera Lens","text":""},{"location":"api/controller/#setcameralens","title":"setCameraLens()","text":"<pre><code>fun setCameraLens(lens: CameraLens)\n</code></pre> <p>Sets camera to front or back.</p> <p>Parameters: - <code>CameraLens.FRONT</code> \u2014 Front camera - <code>CameraLens.BACK</code> \u2014 Back camera</p> <p>Example:</p> <pre><code>controller.setCameraLens(CameraLens.FRONT)\n</code></pre>"},{"location":"api/controller/#getcameralens","title":"getCameraLens()","text":"<pre><code>fun getCameraLens(): CameraLens?\n</code></pre> <p>Returns current camera lens.</p>"},{"location":"api/controller/#togglecameralens","title":"toggleCameraLens()","text":"<pre><code>fun toggleCameraLens()\n</code></pre> <p>Switches between front and back.</p> <p>Example:</p> <pre><code>IconButton(onClick = { controller.toggleCameraLens() }) {\n    Icon(Icons.Default.Cameraswitch, \"Switch Camera\")\n}\n</code></pre>"},{"location":"api/controller/#configuration-getters","title":"Configuration Getters","text":""},{"location":"api/controller/#getimageformat","title":"getImageFormat()","text":"<pre><code>fun getImageFormat(): ImageFormat\n</code></pre> <p>Returns configured image format (JPEG or PNG).</p>"},{"location":"api/controller/#getqualityprioritization","title":"getQualityPrioritization()","text":"<pre><code>fun getQualityPrioritization(): QualityPrioritization\n</code></pre> <p>Returns quality prioritization setting.</p>"},{"location":"api/controller/#getpreferredcameradevicetype","title":"getPreferredCameraDeviceType()","text":"<pre><code>fun getPreferredCameraDeviceType(): CameraDeviceType\n</code></pre> <p>Returns iOS camera device type (ULTRA_WIDE, TELEPHOTO, etc.)</p>"},{"location":"api/controller/#session-management","title":"Session Management","text":""},{"location":"api/controller/#startsession","title":"startSession()","text":"<pre><code>fun startSession()\n</code></pre> <p>Starts camera session. Called automatically.</p>"},{"location":"api/controller/#stopsession","title":"stopSession()","text":"<pre><code>fun stopSession()\n</code></pre> <p>Stops camera session.</p> <p>Example:</p> <pre><code>DisposableEffect(Unit) {\n    onDispose {\n        controller.stopSession()\n    }\n}\n</code></pre>"},{"location":"api/controller/#listeners","title":"Listeners","text":""},{"location":"api/controller/#addimagecapturelistener","title":"addImageCaptureListener()","text":"<pre><code>fun addImageCaptureListener(listener: (ByteArray) -&gt; Unit)\n</code></pre> <p>Adds listener for captured images. Used by plugins.</p> <p>Example:</p> <pre><code>controller.addImageCaptureListener { imageData -&gt;\n    processImage(imageData)\n}\n</code></pre>"},{"location":"api/controller/#removeimagecapturelistener","title":"removeImageCaptureListener()","text":"<pre><code>fun removeImageCaptureListener(listener: (ByteArray) -&gt; Unit)\n</code></pre> <p>Removes image capture listener.</p>"},{"location":"api/controller/#cleanup","title":"Cleanup","text":""},{"location":"api/controller/#cleanup_1","title":"cleanup()","text":"<pre><code>fun cleanup()\n</code></pre> <p>Releases all resources. Called automatically on dispose.</p> <p>Example:</p> <pre><code>DisposableEffect(Unit) {\n    onDispose {\n        controller.cleanup()\n    }\n}\n</code></pre>"},{"location":"api/controller/#complete-example","title":"Complete Example","text":"<pre><code>@Composable\nfun CompleteControllerExample() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n                val maxZoom = remember { controller.getMaxZoom() }\n                var currentZoom by remember { mutableStateOf(1.0f) }\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier\n                        .fillMaxSize()\n                        .pointerInput(Unit) {\n                            detectTransformGestures { _, _, zoom, _ -&gt;\n                                currentZoom = (currentZoom * zoom).coerceIn(1f, maxZoom)\n                                controller.setZoom(currentZoom)\n                            }\n                        }\n                )\n\n                // Top controls\n                Row(\n                    modifier = Modifier\n                        .align(Alignment.TopEnd)\n                        .padding(16.dp),\n                    horizontalArrangement = Arrangement.spacedBy(8.dp)\n                ) {\n                    // Flash toggle\n                    IconButton(onClick = { controller.toggleFlashMode() }) {\n                        Icon(\n                            when (controller.getFlashMode()) {\n                                FlashMode.ON -&gt; Icons.Default.FlashOn\n                                FlashMode.OFF -&gt; Icons.Default.FlashOff\n                                FlashMode.AUTO -&gt; Icons.Default.FlashAuto\n                                else -&gt; Icons.Default.FlashOff\n                            },\n                            \"Flash\"\n                        )\n                    }\n\n                    // Camera switch\n                    IconButton(onClick = { controller.toggleCameraLens() }) {\n                        Icon(Icons.Default.Cameraswitch, \"Switch\")\n                    }\n\n                    // Torch toggle\n                    IconButton(onClick = { controller.toggleTorchMode() }) {\n                        Icon(\n                            if (controller.getTorchMode() == TorchMode.ON)\n                                Icons.Default.FlashlightOn\n                            else Icons.Default.FlashlightOff,\n                            \"Torch\"\n                        )\n                    }\n                }\n\n                // Zoom indicator\n                Text(\n                    text = \"${String.format(\"%.1f\", currentZoom)}x\",\n                    modifier = Modifier\n                        .align(Alignment.TopCenter)\n                        .padding(16.dp),\n                    color = Color.White\n                )\n\n                // Capture button\n                FloatingActionButton(\n                    onClick = {\n                        scope.launch {\n                            when (val result = controller.takePictureToFile()) {\n                                is ImageCaptureResult.SuccessWithFile -&gt; {\n                                    println(\"Saved: ${result.filePath}\")\n                                }\n                                is ImageCaptureResult.Error -&gt; {\n                                    println(\"Error: ${result.exception.message}\")\n                                }\n                            }\n                        }\n                    },\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(32.dp)\n                ) {\n                    Icon(Icons.Default.CameraAlt, \"Capture\")\n                }\n            }\n\n            is CameraKState.Error -&gt; Text(\"Error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre>"},{"location":"api/controller/#platform-availability","title":"Platform Availability","text":"Method Android iOS Desktop <code>takePictureToFile()</code> \u2705 \u2705 \u2705 <code>setZoom()</code> \u2705 \u2705 Limited <code>setFlashMode()</code> \u2705 (rear) \u2705 (rear) \u274c <code>setTorchMode()</code> \u2705 (rear) \u2705 (rear) \u274c <code>toggleCameraLens()</code> \u2705 \u2705 Limited"},{"location":"api/controller/#see-also","title":"See Also","text":"<ul> <li>CameraKStateHolder \u2014 State management</li> <li>Configuration \u2014 Initial configuration</li> <li>Camera Capture Guide \u2014 Capture examples</li> </ul>"},{"location":"api/state-holder/","title":"CameraKStateHolder API","text":"<p>Core state management for CameraK. Manages camera lifecycle, exposes reactive state, and handles plugin coordination.</p>"},{"location":"api/state-holder/#overview","title":"Overview","text":"<p><code>CameraKStateHolder</code> is the primary interface for camera operations. It manages: - Camera lifecycle (initialization \u2192 ready \u2192 cleanup) - Reactive state via <code>StateFlow</code> - Plugin lifecycle and coordination - One-shot events via <code>SharedFlow</code></p>"},{"location":"api/state-holder/#creation","title":"Creation","text":"<pre><code>@Composable\nfun rememberCameraKState(\n    permissions: PermissionController,\n    cameraConfiguration: CameraConfiguration.() -&gt; Unit = {},\n    plugins: List&lt;CameraKPlugin&gt; = emptyList(),\n    onStateChange: (CameraKState) -&gt; Unit = {}\n): CameraKStateHolder\n</code></pre> <p>Parameters: - <code>permissions</code> \u2014 Platform-specific permission controller from <code>providePermissions()</code> - <code>cameraConfiguration</code> \u2014 DSL for camera configuration - <code>plugins</code> \u2014 List of plugins to attach - <code>onStateChange</code> \u2014 Callback for state changes (optional)</p> <p>Example:</p> <pre><code>val stateHolder = rememberCameraKState(\n    permissions = providePermissions(),\n    cameraConfiguration = {\n        setCameraLens(CameraLens.BACK)\n        setFlashMode(FlashMode.AUTO)\n        setAspectRatio(AspectRatio.RATIO_16_9)\n    },\n    plugins = listOf(\n        rememberQRScannerPlugin(),\n        rememberOcrPlugin()\n    )\n)\n</code></pre>"},{"location":"api/state-holder/#properties","title":"Properties","text":""},{"location":"api/state-holder/#camerastate","title":"cameraState","text":"<pre><code>val cameraState: StateFlow&lt;CameraKState&gt;\n</code></pre> <p>Observable camera lifecycle state. Emits: - <code>CameraKState.Initializing</code> \u2014 Camera starting - <code>CameraKState.Ready(controller)</code> \u2014 Camera operational - <code>CameraKState.Error(exception)</code> \u2014 Initialization failed</p> <p>Usage:</p> <pre><code>val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n\nwhen (cameraState) {\n    is CameraKState.Initializing -&gt; CircularProgressIndicator()\n    is CameraKState.Ready -&gt; {\n        val controller = (cameraState as CameraKState.Ready).controller\n        CameraPreviewComposable(controller = controller)\n    }\n    is CameraKState.Error -&gt; {\n        val error = (cameraState as CameraKState.Error).exception\n        Text(\"Error: ${error.message}\")\n    }\n}\n</code></pre>"},{"location":"api/state-holder/#uistate","title":"uiState","text":"<pre><code>val uiState: StateFlow&lt;CameraUIState&gt;\n</code></pre> <p>Observable UI properties (zoom level, flash mode, capturing state, etc.)</p> <p>CameraUIState structure:</p> <pre><code>data class CameraUIState(\n    val zoomLevel: Float = 1.0f,\n    val maxZoom: Float = 1.0f,\n    val flashMode: FlashMode = FlashMode.AUTO,\n    val cameraLens: CameraLens = CameraLens.BACK,\n    val isCapturing: Boolean = false,\n    val lastError: String? = null\n)\n</code></pre> <p>Usage:</p> <pre><code>val uiState by stateHolder.uiState.collectAsStateWithLifecycle()\n\nText(\"Zoom: ${uiState.zoomLevel}x\")\nText(\"Max: ${uiState.maxZoom}x\")\n</code></pre>"},{"location":"api/state-holder/#events","title":"events","text":"<pre><code>val events: SharedFlow&lt;CameraKEvent&gt;\n</code></pre> <p>One-shot events (not persisted). Collect to handle events like capture success/failure.</p> <p>CameraKEvent types:</p> <pre><code>sealed class CameraKEvent {\n    data class ImageCaptured(val result: ImageCaptureResult) : CameraKEvent()\n    data class CaptureFailed(val exception: Exception) : CameraKEvent()\n    data class ZoomChanged(val zoom: Float) : CameraKEvent()\n    data class FlashModeChanged(val mode: FlashMode) : CameraKEvent()\n}\n</code></pre> <p>Usage:</p> <pre><code>LaunchedEffect(Unit) {\n    stateHolder.events.collect { event -&gt;\n        when (event) {\n            is CameraKEvent.ImageCaptured -&gt; {\n                showToast(\"Photo captured!\")\n            }\n            is CameraKEvent.CaptureFailed -&gt; {\n                showToast(\"Capture failed: ${event.exception.message}\")\n            }\n            else -&gt; {}\n        }\n    }\n}\n</code></pre>"},{"location":"api/state-holder/#qrcodeflow","title":"qrCodeFlow","text":"<pre><code>val qrCodeFlow: StateFlow&lt;List&lt;String&gt;&gt;\n</code></pre> <p>Scanned QR codes. Populated automatically by QR Scanner Plugin.</p> <p>Usage:</p> <pre><code>val qrCodes by stateHolder.qrCodeFlow.collectAsStateWithLifecycle(initial = emptyList())\n\nif (qrCodes.isNotEmpty()) {\n    Text(\"Latest QR: ${qrCodes.last()}\")\n}\n</code></pre>"},{"location":"api/state-holder/#recognizedtextflow","title":"recognizedTextFlow","text":"<pre><code>val recognizedTextFlow: StateFlow&lt;String&gt;\n</code></pre> <p>Recognized text via OCR. Populated automatically by OCR Plugin.</p> <p>Usage:</p> <pre><code>val recognizedText by stateHolder.recognizedTextFlow.collectAsStateWithLifecycle(initial = \"\")\n\nif (recognizedText.isNotEmpty()) {\n    Text(\"OCR: $recognizedText\")\n}\n</code></pre>"},{"location":"api/state-holder/#pluginscope","title":"pluginScope","text":"<pre><code>val pluginScope: CoroutineScope\n</code></pre> <p>CoroutineScope for plugin operations. Automatically cancelled when state holder is disposed.</p>"},{"location":"api/state-holder/#methods","title":"Methods","text":""},{"location":"api/state-holder/#getcontroller","title":"getController()","text":"<pre><code>fun getController(): CameraController?\n</code></pre> <p>Get camera controller if available (state is <code>Ready</code>).</p> <p>Returns: <code>CameraController</code> or <code>null</code> if camera not ready.</p> <p>Example:</p> <pre><code>val controller = stateHolder.getController()\nif (controller != null) {\n    controller.setZoom(2.0f)\n} else {\n    println(\"Camera not ready\")\n}\n</code></pre>"},{"location":"api/state-holder/#getreadycameracontroller","title":"getReadyCameraController()","text":"<pre><code>suspend fun getReadyCameraController(): CameraController?\n</code></pre> <p>Suspends until camera is ready, then returns controller. Use in plugins.</p> <p>Returns: <code>CameraController</code> or <code>null</code> if error occurs.</p> <p>Example:</p> <pre><code>scope.launch {\n    val controller = stateHolder.getReadyCameraController()\n    controller?.setFlashMode(FlashMode.ON)\n}\n</code></pre>"},{"location":"api/state-holder/#captureimage","title":"captureImage()","text":"<pre><code>fun captureImage()\n</code></pre> <p>Captures an image and emits <code>CameraKEvent.ImageCaptured</code> or <code>CameraKEvent.CaptureFailed</code>.</p> <p>Example:</p> <pre><code>Button(onClick = { stateHolder.captureImage() }) {\n    Text(\"Capture\")\n}\n\n// Listen for result\nLaunchedEffect(Unit) {\n    stateHolder.events.collect { event -&gt;\n        when (event) {\n            is CameraKEvent.ImageCaptured -&gt; {\n                when (val result = event.result) {\n                    is ImageCaptureResult.SuccessWithFile -&gt; {\n                        println(\"Saved: ${result.filePath}\")\n                    }\n                    is ImageCaptureResult.Error -&gt; {\n                        println(\"Error: ${result.exception.message}\")\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"api/state-holder/#setzoom","title":"setZoom()","text":"<pre><code>fun setZoom(zoom: Float)\n</code></pre> <p>Sets zoom level. Updates <code>uiState.zoomLevel</code> and emits <code>CameraKEvent.ZoomChanged</code>.</p> <p>Parameters: - <code>zoom</code> \u2014 Zoom level (1.0 to maxZoom)</p> <p>Example:</p> <pre><code>stateHolder.setZoom(2.5f)\n</code></pre>"},{"location":"api/state-holder/#togglecameralens","title":"toggleCameraLens()","text":"<pre><code>fun toggleCameraLens()\n</code></pre> <p>Switches between front and back cameras.</p> <p>Example:</p> <pre><code>IconButton(onClick = { stateHolder.toggleCameraLens() }) {\n    Icon(Icons.Default.Cameraswitch, \"Switch Camera\")\n}\n</code></pre>"},{"location":"api/state-holder/#initialize","title":"initialize()","text":"<pre><code>fun initialize()\n</code></pre> <p>Initializes camera. Called automatically by <code>rememberCameraKState</code>. Don't call manually.</p>"},{"location":"api/state-holder/#shutdown","title":"shutdown()","text":"<pre><code>fun shutdown()\n</code></pre> <p>Cleans up resources. Called automatically when composable leaves composition.</p>"},{"location":"api/state-holder/#complete-example","title":"Complete Example","text":"<pre><code>@Composable\nfun CompleteStateHolderExample() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n\n    val stateHolder = rememberCameraKState(\n        permissions = permissions,\n        cameraConfiguration = {\n            setCameraLens(CameraLens.BACK)\n            setFlashMode(FlashMode.AUTO)\n            setAspectRatio(AspectRatio.RATIO_16_9)\n        },\n        plugins = listOf(rememberQRScannerPlugin())\n    )\n\n    // Observe state\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    val uiState by stateHolder.uiState.collectAsStateWithLifecycle()\n    val qrCodes by stateHolder.qrCodeFlow.collectAsStateWithLifecycle(initial = emptyList())\n\n    // Listen for events\n    LaunchedEffect(Unit) {\n        stateHolder.events.collect { event -&gt;\n            when (event) {\n                is CameraKEvent.ImageCaptured -&gt; {\n                    println(\"Photo captured!\")\n                }\n                is CameraKEvent.ZoomChanged -&gt; {\n                    println(\"Zoom: ${event.zoom}x\")\n                }\n            }\n        }\n    }\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                // UI State display\n                Column(\n                    modifier = Modifier\n                        .align(Alignment.TopStart)\n                        .padding(16.dp)\n                ) {\n                    Text(\"Zoom: ${uiState.zoomLevel}x / ${uiState.maxZoom}x\")\n                    Text(\"Flash: ${uiState.flashMode}\")\n                    Text(\"Lens: ${uiState.cameraLens}\")\n                    if (qrCodes.isNotEmpty()) {\n                        Text(\"QR: ${qrCodes.last()}\")\n                    }\n                }\n\n                // Capture button\n                FloatingActionButton(\n                    onClick = { stateHolder.captureImage() },\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(32.dp)\n                ) {\n                    if (uiState.isCapturing) {\n                        CircularProgressIndicator(color = Color.White, modifier = Modifier.size(24.dp))\n                    } else {\n                        Icon(Icons.Default.CameraAlt, \"Capture\")\n                    }\n                }\n\n                // Zoom slider\n                Slider(\n                    value = uiState.zoomLevel,\n                    onValueChange = { stateHolder.setZoom(it) },\n                    valueRange = 1f..uiState.maxZoom,\n                    modifier = Modifier\n                        .align(Alignment.CenterEnd)\n                        .width(200.dp)\n                        .graphicsLayer { rotationZ = 270f }\n                )\n            }\n\n            is CameraKState.Error -&gt; {\n                Text(\"Camera error: ${(cameraState as CameraKState.Error).exception.message}\")\n            }\n\n            CameraKState.Initializing -&gt; {\n                CircularProgressIndicator()\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"api/state-holder/#thread-safety","title":"Thread Safety","text":"<p>All public methods are thread-safe. State updates are synchronized internally.</p>"},{"location":"api/state-holder/#lifecycle","title":"Lifecycle","text":"<ol> <li>Creation \u2014 <code>rememberCameraKState()</code> creates state holder</li> <li>Initialization \u2014 Camera hardware initialized</li> <li>Ready \u2014 Camera operational, plugins activated</li> <li>Cleanup \u2014 Resources released when composable leaves composition</li> </ol>"},{"location":"api/state-holder/#see-also","title":"See Also","text":"<ul> <li>CameraController API \u2014 Low-level camera operations</li> <li>Configuration \u2014 Configuration options</li> <li>Camera Capture Guide \u2014 Capture examples</li> </ul>"},{"location":"examples/android/","title":"Android Setup","text":"<p>Setup CameraK for Android applications.</p>"},{"location":"examples/android/#requirements","title":"Requirements","text":"<ul> <li>Minimum SDK: API 21 (Android 5.0 Lollipop)</li> <li>Target SDK: API 34+ recommended</li> <li>Kotlin: 1.9.0+</li> <li>Gradle: 8.0+</li> <li>Compose: 1.5.0+</li> </ul>"},{"location":"examples/android/#step-1-add-dependency","title":"Step 1: Add Dependency","text":""},{"location":"examples/android/#buildgradlekts-module-level","title":"build.gradle.kts (Module-level)","text":"<pre><code>dependencies {\n    implementation(\"io.github.kashif-mehmood-km:camerak:0.2.0\")\n}\n</code></pre>"},{"location":"examples/android/#version-catalog","title":"Version Catalog","text":"<p><code>gradle/libs.versions.toml</code>:</p> <pre><code>[versions]\ncamerak = \"0.2.0\"\n\n[libraries]\ncamerak = { module = \"io.github.kashif-mehmood-km:camerak\", version.ref = \"camerak\" }\n</code></pre> <p><code>build.gradle.kts</code>:</p> <pre><code>dependencies {\n    implementation(libs.camerak)\n}\n</code></pre>"},{"location":"examples/android/#step-2-permissions","title":"Step 2: Permissions","text":""},{"location":"examples/android/#androidmanifestxml","title":"AndroidManifest.xml","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n\n    &lt;!-- Camera feature --&gt;\n    &lt;uses-feature \n        android:name=\"android.hardware.camera\" \n        android:required=\"true\" /&gt;\n\n    &lt;!-- Camera permission --&gt;\n    &lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt;\n\n    &lt;!-- Storage permission (Android 9 and below) --&gt;\n    &lt;uses-permission \n        android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"\n        android:maxSdkVersion=\"28\" /&gt;\n\n    &lt;application\n        android:name=\".MyApplication\"\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:theme=\"@style/Theme.App\"&gt;\n\n        &lt;activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre>"},{"location":"examples/android/#step-3-request-permissions","title":"Step 3: Request Permissions","text":""},{"location":"examples/android/#using-accompanist-permissions","title":"Using Accompanist Permissions","text":"<p>Add dependency:</p> <pre><code>dependencies {\n    implementation(\"com.google.accompanist:accompanist-permissions:0.32.0\")\n}\n</code></pre> <p>Request permissions in Compose:</p> <pre><code>@Composable\nfun CameraScreenWithPermissions() {\n    val cameraPermissionState = rememberPermissionState(\n        android.Manifest.permission.CAMERA\n    )\n\n    LaunchedEffect(Unit) {\n        if (!cameraPermissionState.status.isGranted) {\n            cameraPermissionState.launchPermissionRequest()\n        }\n    }\n\n    when {\n        cameraPermissionState.status.isGranted -&gt; {\n            CameraScreen()  // Your camera UI\n        }\n        cameraPermissionState.status.shouldShowRationale -&gt; {\n            PermissionRationaleDialog(\n                onRequestPermission = { cameraPermissionState.launchPermissionRequest() }\n            )\n        }\n        else -&gt; {\n            PermissionDeniedScreen()\n        }\n    }\n}\n</code></pre>"},{"location":"examples/android/#using-cameraks-built-in-permission-provider","title":"Using CameraK's Built-in Permission Provider","text":"<pre><code>@Composable\nfun CameraScreen() {\n    val permissions = providePermissions()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n\n    // Camera automatically requests permissions\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n\n    when (cameraState) {\n        is CameraKState.Ready -&gt; {\n            // Camera ready - permissions granted\n            CameraPreviewComposable(...)\n        }\n        is CameraKState.Error -&gt; {\n            // Check if error is permission-related\n            Text(\"Camera error: ${(cameraState as CameraKState.Error).exception.message}\")\n        }\n        CameraKState.Initializing -&gt; {\n            CircularProgressIndicator()\n        }\n    }\n}\n</code></pre>"},{"location":"examples/android/#step-4-basic-implementation","title":"Step 4: Basic Implementation","text":"<pre><code>@Composable\nfun AndroidCameraScreen() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(\n        permissions = permissions,\n        cameraConfiguration = {\n            setCameraLens(CameraLens.BACK)\n            setFlashMode(FlashMode.AUTO)\n            setAspectRatio(AspectRatio.RATIO_16_9)\n            setImageFormat(ImageFormat.JPEG)\n            setDirectory(Directory.PICTURES)\n        }\n    )\n\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                // Camera preview\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                // Capture button\n                FloatingActionButton(\n                    onClick = {\n                        scope.launch {\n                            when (val result = controller.takePictureToFile()) {\n                                is ImageCaptureResult.SuccessWithFile -&gt; {\n                                    Toast.makeText(\n                                        context,\n                                        \"Photo saved: ${result.filePath}\",\n                                        Toast.LENGTH_SHORT\n                                    ).show()\n                                }\n                                is ImageCaptureResult.Error -&gt; {\n                                    Toast.makeText(\n                                        context,\n                                        \"Error: ${result.exception.message}\",\n                                        Toast.LENGTH_SHORT\n                                    ).show()\n                                }\n                            }\n                        }\n                    },\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(32.dp)\n                ) {\n                    Icon(Icons.Default.CameraAlt, contentDescription = \"Capture\")\n                }\n            }\n\n            is CameraKState.Error -&gt; {\n                Text(\n                    text = \"Camera Error: ${(cameraState as CameraKState.Error).exception.message}\",\n                    modifier = Modifier.align(Alignment.Center)\n                )\n            }\n\n            CameraKState.Initializing -&gt; {\n                CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"examples/android/#step-5-proguard-rules","title":"Step 5: ProGuard Rules","text":"<p>If using ProGuard/R8, add rules:</p>"},{"location":"examples/android/#proguard-rulespro","title":"proguard-rules.pro","text":"<pre><code># CameraK\n-keep class com.kashif.cameraK.** { *; }\n-keepclassmembers class com.kashif.cameraK.** { *; }\n\n# CameraX\n-keep class androidx.camera.** { *; }\n-keepclassmembers class androidx.camera.** { *; }\n</code></pre>"},{"location":"examples/android/#file-storage-paths","title":"File Storage Paths","text":"<p>On Android, photos are saved to:</p> <ul> <li><code>Directory.PICTURES</code> \u2192 <code>/storage/emulated/0/Pictures/</code></li> <li><code>Directory.DCIM</code> \u2192 <code>/storage/emulated/0/DCIM/</code></li> <li><code>Directory.DOWNLOADS</code> \u2192 <code>/storage/emulated/0/Download/</code></li> <li><code>Directory.DOCUMENTS</code> \u2192 <code>/data/data/your.package/files/Documents/</code></li> <li><code>Directory.CACHE</code> \u2192 <code>/data/data/your.package/cache/</code></li> </ul>"},{"location":"examples/android/#testing","title":"Testing","text":""},{"location":"examples/android/#emulator-setup","title":"Emulator Setup","text":"<ol> <li>Create AVD with camera support</li> <li>Enable camera in AVD settings:</li> <li>Front camera: Webcam or Emulated</li> <li>Back camera: VirtualScene or Emulated</li> </ol>"},{"location":"examples/android/#physical-device","title":"Physical Device","text":"<p>Test on real device for: - Flash/torch functionality - Camera switching - High-resolution capture - Performance testing</p>"},{"location":"examples/android/#common-issues","title":"Common Issues","text":""},{"location":"examples/android/#camera-not-available","title":"\"Camera not available\"","text":"<p>Cause: Emulator doesn't have camera configured.</p> <p>Solution: Use physical device or configure AVD camera.</p>"},{"location":"examples/android/#permission-denied","title":"\"Permission denied\"","text":"<p>Cause: Camera permission not granted.</p> <p>Solution: Check manifest has <code>&lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt;</code>.</p>"},{"location":"examples/android/#no-space-left-on-device","title":"\"No space left on device\"","text":"<p>Cause: Storage full.</p> <p>Solution: Clear device storage or use <code>Directory.CACHE</code> for temporary files.</p>"},{"location":"examples/android/#camerax-initialization-error","title":"CameraX Initialization Error","text":"<p>Cause: CameraX version conflict.</p> <p>Solution: CameraK includes CameraX automatically - don't add manual CameraX dependencies.</p>"},{"location":"examples/android/#platform-specific-features","title":"Platform-Specific Features","text":""},{"location":"examples/android/#android-only-features","title":"Android-Only Features","text":"<ul> <li>Image Analysis \u2014 Process frames in real-time</li> <li>CameraX Integration \u2014 Built on Android's CameraX</li> <li>Scoped Storage \u2014 Android 10+ privacy-safe storage</li> </ul>"},{"location":"examples/android/#configuration-example","title":"Configuration Example","text":"<pre><code>val stateHolder = rememberCameraKState(\n    permissions = permissions,\n    cameraConfiguration = {\n        // Android supports all features\n        setCameraLens(CameraLens.BACK)\n        setAspectRatio(AspectRatio.RATIO_16_9)\n        setResolution(1920 to 1080)\n        setFlashMode(FlashMode.AUTO)\n        setImageFormat(ImageFormat.JPEG)\n        setDirectory(Directory.PICTURES)\n        setQualityPrioritization(QualityPrioritization.BALANCED)\n    }\n)\n</code></pre>"},{"location":"examples/android/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start \u2014 Build your first camera app</li> <li>Configuration \u2014 Customize settings</li> <li>Camera Capture \u2014 Advanced capture techniques</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>Configure camera behavior, output format, and platform-specific features.</p>"},{"location":"getting-started/configuration/#configuration-dsl","title":"Configuration DSL","text":"<p>Pass configuration during initialization:</p> <pre><code>val stateHolder = rememberCameraKState(\n    permissions = permissions,\n    cameraConfiguration = {\n        // Your configuration here\n    }\n)\n</code></pre>"},{"location":"getting-started/configuration/#camera-selection","title":"Camera Selection","text":""},{"location":"getting-started/configuration/#set-initial-camera-lens","title":"Set Initial Camera Lens","text":"<pre><code>cameraConfiguration = {\n    setCameraLens(CameraLens.BACK)  // or CameraLens.FRONT\n}\n</code></pre> <p>Options: - <code>CameraLens.BACK</code> \u2014 Rear-facing camera (default) - <code>CameraLens.FRONT</code> \u2014 Front-facing camera</p> <p>Switch at runtime:</p> <pre><code>controller.toggleCameraLens()\n// or\ncontroller.setCameraLens(CameraLens.FRONT)\n</code></pre>"},{"location":"getting-started/configuration/#ios-advanced-camera-types","title":"iOS: Advanced Camera Types","text":"<p>On iOS devices with multiple cameras, select specific lenses:</p> <pre><code>cameraConfiguration = {\n    setCameraDeviceType(CameraDeviceType.ULTRA_WIDE)\n}\n</code></pre> <p>Options: - <code>CameraDeviceType.DEFAULT</code> \u2014 Standard wide-angle (default) - <code>CameraDeviceType.ULTRA_WIDE</code> \u2014 Ultra-wide lens (0.5x zoom) - <code>CameraDeviceType.TELEPHOTO</code> \u2014 Telephoto lens (2x-3x zoom) - <code>CameraDeviceType.WIDE_ANGLE</code> \u2014 Wide-angle lens</p> <p>Availability: Depends on device hardware (iPhone 11 Pro+, iPhone 13+, etc.)</p>"},{"location":"getting-started/configuration/#aspect-ratio","title":"Aspect Ratio","text":"<p>Set the capture aspect ratio:</p> <pre><code>cameraConfiguration = {\n    setAspectRatio(AspectRatio.RATIO_16_9)\n}\n</code></pre> <p>Options:</p> Aspect Ratio Use Case Resolution Example <code>RATIO_4_3</code> Traditional photos 2048\u00d71536 <code>RATIO_16_9</code> Widescreen (default) 1920\u00d71080 <code>RATIO_9_16</code> Vertical stories 1080\u00d71920 <code>RATIO_1_1</code> Square photos 1080\u00d71080 <p>Example:</p> <pre><code>// Instagram story mode\ncameraConfiguration = {\n    setAspectRatio(AspectRatio.RATIO_9_16)\n}\n</code></pre>"},{"location":"getting-started/configuration/#resolution","title":"Resolution","text":"<p>Optionally set specific resolution:</p> <pre><code>cameraConfiguration = {\n    setResolution(1920 to 1080)  // width \u00d7 height\n}\n</code></pre> <p>Common resolutions: - <code>1920 to 1080</code> \u2014 Full HD - <code>1280 to 720</code> \u2014 HD - <code>3840 to 2160</code> \u2014 4K (if supported)</p> <p>Note: If device doesn't support exact resolution, closest match is used.</p>"},{"location":"getting-started/configuration/#flash-mode","title":"Flash Mode","text":"<p>Control flash behavior:</p> <pre><code>cameraConfiguration = {\n    setFlashMode(FlashMode.AUTO)\n}\n</code></pre> <p>Options: - <code>FlashMode.OFF</code> \u2014 Flash disabled - <code>FlashMode.ON</code> \u2014 Flash always fires - <code>FlashMode.AUTO</code> \u2014 Flash fires in low light (default)</p> <p>Runtime control:</p> <pre><code>controller.setFlashMode(FlashMode.ON)\ncontroller.toggleFlashMode()  // Cycles: OFF \u2192 ON \u2192 AUTO\n\nval currentMode = controller.getFlashMode()  // returns FlashMode?\n</code></pre>"},{"location":"getting-started/configuration/#image-format","title":"Image Format","text":"<p>Set output format:</p> <pre><code>cameraConfiguration = {\n    setImageFormat(ImageFormat.JPEG)\n}\n</code></pre> <p>Options:</p> Format Compression File Size Use Case <code>JPEG</code> Lossy Smaller Web, sharing (default) <code>PNG</code> Lossless Larger Transparency, archival <p>Example:</p> <pre><code>// High-quality archival photos\ncameraConfiguration = {\n    setImageFormat(ImageFormat.PNG)\n}\n</code></pre>"},{"location":"getting-started/configuration/#save-directory","title":"Save Directory","text":"<p>Choose where captured images are saved:</p> <pre><code>cameraConfiguration = {\n    setDirectory(Directory.PICTURES)\n}\n</code></pre> <p>Options:</p> Directory Android Path iOS Path <code>PICTURES</code> <code>Environment.DIRECTORY_PICTURES</code> Photo Library (default) <code>DCIM</code> <code>Environment.DIRECTORY_DCIM</code> Photo Library <code>DOCUMENTS</code> <code>getExternalFilesDir(DOCUMENTS)</code> Documents folder <code>DOWNLOADS</code> <code>Environment.DIRECTORY_DOWNLOADS</code> Downloads folder <code>CACHE</code> <code>cacheDir</code> Temporary cache <p>Example:</p> <pre><code>// Save to downloads for easy access\ncameraConfiguration = {\n    setDirectory(Directory.DOWNLOADS)\n}\n</code></pre>"},{"location":"getting-started/configuration/#quality-prioritization","title":"Quality Prioritization","text":"<p>Balance between capture speed and image quality:</p> <pre><code>cameraConfiguration = {\n    setQualityPrioritization(QualityPrioritization.BALANCED)\n}\n</code></pre> <p>Options: - <code>QualityPrioritization.QUALITY</code> \u2014 Best quality, slower capture - <code>QualityPrioritization.BALANCED</code> \u2014 Good balance (default) - <code>QualityPrioritization.SPEED</code> \u2014 Fast capture, lower quality</p> <p>Use cases: - <code>QUALITY</code>: Professional photography, print media - <code>BALANCED</code>: General-purpose apps - <code>SPEED</code>: Burst mode, document scanning</p>"},{"location":"getting-started/configuration/#complete-example","title":"Complete Example","text":"<pre><code>@Composable\nfun ProfessionalCameraScreen() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n\n    val stateHolder = rememberCameraKState(\n        permissions = permissions,\n        cameraConfiguration = {\n            // Camera hardware\n            setCameraLens(CameraLens.BACK)\n            setCameraDeviceType(CameraDeviceType.TELEPHOTO)  // iOS only\n\n            // Image properties\n            setAspectRatio(AspectRatio.RATIO_4_3)\n            setResolution(3840 to 2160)  // 4K\n            setImageFormat(ImageFormat.PNG)\n\n            // Quality settings\n            setQualityPrioritization(QualityPrioritization.QUALITY)\n\n            // Flash and storage\n            setFlashMode(FlashMode.AUTO)\n            setDirectory(Directory.PICTURES)\n        }\n    )\n\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                FloatingActionButton(\n                    onClick = {\n                        scope.launch {\n                            when (val result = controller.takePictureToFile()) {\n                                is ImageCaptureResult.SuccessWithFile -&gt; {\n                                    println(\"Saved 4K PNG: ${result.filePath}\")\n                                }\n                                is ImageCaptureResult.Error -&gt; {\n                                    println(\"Error: ${result.exception.message}\")\n                                }\n                            }\n                        }\n                    },\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(32.dp)\n                ) {\n                    Icon(Icons.Default.CameraAlt, \"Capture\")\n                }\n            }\n\n            is CameraKState.Error -&gt; {\n                Text(\"Camera error\")\n            }\n\n            CameraKState.Initializing -&gt; {\n                CircularProgressIndicator()\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/configuration/#runtime-configuration","title":"Runtime Configuration","text":"<p>Some settings can be changed after initialization:</p>"},{"location":"getting-started/configuration/#zoom","title":"Zoom","text":"<pre><code>val maxZoom = controller.getMaxZoom()  // e.g., 10.0\ncontroller.setZoom(2.5f)  // 2.5x zoom\nval currentZoom = controller.getZoom()  // returns 2.5\n</code></pre>"},{"location":"getting-started/configuration/#flash","title":"Flash","text":"<pre><code>controller.setFlashMode(FlashMode.ON)\ncontroller.toggleFlashMode()  // OFF \u2192 ON \u2192 AUTO \u2192 OFF\n</code></pre>"},{"location":"getting-started/configuration/#torch-flashlight","title":"Torch (Flashlight)","text":"<pre><code>controller.toggleTorchMode()  // Toggle continuous light\n</code></pre>"},{"location":"getting-started/configuration/#camera-lens","title":"Camera Lens","text":"<pre><code>controller.setCameraLens(CameraLens.FRONT)\ncontroller.toggleCameraLens()  // BACK \u2194 FRONT\n</code></pre>"},{"location":"getting-started/configuration/#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"getting-started/configuration/#android","title":"Android","text":"<ul> <li>CameraX handles resolution selection automatically if not specified</li> <li>Flash modes depend on device hardware</li> <li>Some devices don't support all aspect ratios</li> </ul>"},{"location":"getting-started/configuration/#ios","title":"iOS","text":"<ul> <li><code>CameraDeviceType</code> only works on devices with multiple cameras</li> <li>Resolution is constrained by selected <code>AVCaptureSessionPreset</code></li> <li>Flash availability depends on camera type (front cameras often lack flash)</li> </ul>"},{"location":"getting-started/configuration/#desktop","title":"Desktop","text":"<ul> <li>Resolution depends on webcam capabilities</li> <li>Flash and torch are usually not available</li> <li>Camera switching depends on multiple webcam availability</li> </ul>"},{"location":"getting-started/configuration/#configuration-reference","title":"Configuration Reference","text":"Method Parameter Type Default Platforms <code>setCameraLens()</code> <code>CameraLens</code> <code>BACK</code> All <code>setCameraDeviceType()</code> <code>CameraDeviceType</code> <code>DEFAULT</code> iOS only <code>setAspectRatio()</code> <code>AspectRatio</code> <code>RATIO_16_9</code> All <code>setResolution()</code> <code>Pair&lt;Int, Int&gt;</code> Device default All <code>setFlashMode()</code> <code>FlashMode</code> <code>AUTO</code> Android, iOS <code>setImageFormat()</code> <code>ImageFormat</code> <code>JPEG</code> All <code>setDirectory()</code> <code>Directory</code> <code>PICTURES</code> All <code>setQualityPrioritization()</code> <code>QualityPrioritization</code> <code>BALANCED</code> All"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Camera Capture \u2014 Capture photos and handle results</li> <li>Zoom Control \u2014 Implement pinch-to-zoom</li> <li>Flash and Torch \u2014 Control lighting</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Add CameraK to your Kotlin Multiplatform project in under 5 minutes.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kotlin 1.9.0 or higher</li> <li>Gradle 8.0 or higher</li> <li>Target platforms:<ul> <li>Android: API 21+ (Android 5.0)</li> <li>iOS: iOS 13.0+</li> <li>Desktop: JDK 11+</li> </ul> </li> </ul>"},{"location":"getting-started/installation/#step-1-add-dependencies","title":"Step 1: Add Dependencies","text":""},{"location":"getting-started/installation/#using-gradle-kotlin-dsl","title":"Using Gradle (Kotlin DSL)","text":"<p>Add to your <code>build.gradle.kts</code>:</p> <pre><code>kotlin {\n    sourceSets {\n        commonMain.dependencies {\n            implementation(\"io.github.kashif-mehmood-km:camerak:0.2.0\")\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/installation/#using-version-catalog","title":"Using Version Catalog","text":"<p>Add to <code>gradle/libs.versions.toml</code>:</p> <pre><code>[versions]\ncamerak = \"0.2.0\"\n\n[libraries]\ncamerak = { module = \"io.github.kashif-mehmood-km:camerak\", version.ref = \"camerak\" }\n</code></pre> <p>Then in <code>build.gradle.kts</code>:</p> <pre><code>kotlin {\n    sourceSets {\n        commonMain.dependencies {\n            implementation(libs.camerak)\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/installation/#android-only-project","title":"Android-Only Project","text":"<pre><code>dependencies {\n    implementation(\"io.github.kashif-mehmood-km:camerak:0.2.0\")\n}\n</code></pre>"},{"location":"getting-started/installation/#step-2-platform-specific-setup","title":"Step 2: Platform-Specific Setup","text":""},{"location":"getting-started/installation/#android","title":"Android","text":"<p>Add permissions to <code>AndroidManifest.xml</code>:</p> <pre><code>&lt;manifest&gt;\n    &lt;uses-feature android:name=\"android.hardware.camera\" android:required=\"true\" /&gt;\n    &lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt;\n    &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"\n        android:maxSdkVersion=\"28\" /&gt;\n&lt;/manifest&gt;\n</code></pre> <p>No additional configuration needed \u2014 CameraX is included automatically.</p>"},{"location":"getting-started/installation/#ios","title":"iOS","text":"<p>Add usage descriptions to <code>Info.plist</code>:</p> <pre><code>&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;\n&lt;string&gt;This app needs camera access to capture photos&lt;/string&gt;\n&lt;key&gt;NSPhotoLibraryAddUsageDescription&lt;/key&gt;\n&lt;string&gt;This app needs to save photos to your library&lt;/string&gt;\n</code></pre>"},{"location":"getting-started/installation/#desktop-jvm","title":"Desktop (JVM)","text":"<p>No additional setup required. JavaCV dependencies are included automatically.</p>"},{"location":"getting-started/installation/#step-3-sync-project","title":"Step 3: Sync Project","text":"<p>Run Gradle sync:</p> <pre><code>./gradlew build\n</code></pre>"},{"location":"getting-started/installation/#optional-add-plugins","title":"Optional: Add Plugins","text":""},{"location":"getting-started/installation/#qr-scanner-plugin","title":"QR Scanner Plugin","text":"<pre><code>dependencies {\n    implementation(\"io.github.kashif-mehmood-km:qr_scanner_plugin:0.2.0\")\n}\n</code></pre>"},{"location":"getting-started/installation/#ocr-plugin","title":"OCR Plugin","text":"<pre><code>dependencies {\n    implementation(\"io.github.kashif-mehmood-km:ocr_plugin:0.2.0\")\n}\n</code></pre>"},{"location":"getting-started/installation/#image-saver-plugin","title":"Image Saver Plugin","text":"<pre><code>dependencies {\n    implementation(\"io.github.kashif-mehmood-km:image_saver_plugin:0.2.0\")\n}\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Create a simple test to verify:</p> <pre><code>@Composable\nfun TestCameraScreen() {\n    val permissions = providePermissions()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n\n    when (cameraState) {\n        is CameraKState.Ready -&gt; Text(\"\u2705 CameraK is ready!\")\n        is CameraKState.Error -&gt; Text(\"\u274c Error: ${cameraState.exception.message}\")\n        CameraKState.Initializing -&gt; CircularProgressIndicator()\n    }\n}\n</code></pre> <p>If you see \"CameraK is ready!\" \u2014 you're all set!</p>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#android-camerax-not-found","title":"Android: \"CameraX not found\"","text":"<p>Ensure you're using API 21+:</p> <pre><code>android {\n    defaultConfig {\n        minSdk = 21\n    }\n}\n</code></pre>"},{"location":"getting-started/installation/#ios-camera-permission-denied","title":"iOS: \"Camera permission denied\"","text":"<p>Check your <code>Info.plist</code> has <code>NSCameraUsageDescription</code>.</p>"},{"location":"getting-started/installation/#desktop-no-camera-detected","title":"Desktop: \"No camera detected\"","text":"<p>Ensure a webcam is connected and accessible by your OS.</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide \u2014 Build your first camera app</li> <li>Configuration \u2014 Customize camera behavior</li> <li>Platform-Specific Guides \u2014 Deep dives per platform</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Build your first camera app in 5 minutes.</p>"},{"location":"getting-started/quick-start/#basic-camera-screen","title":"Basic Camera Screen","text":"<pre><code>@Composable\nfun CameraScreen() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                // Camera preview\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                // Capture button\n                FloatingActionButton(\n                    onClick = {\n                        scope.launch {\n                            when (val result = controller.takePictureToFile()) {\n                                is ImageCaptureResult.SuccessWithFile -&gt; {\n                                    println(\"Photo saved to: ${result.filePath}\")\n                                }\n                                is ImageCaptureResult.Error -&gt; {\n                                    println(\"Capture failed: ${result.exception.message}\")\n                                }\n                            }\n                        }\n                    },\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(16.dp)\n                ) {\n                    Icon(Icons.Default.CameraAlt, contentDescription = \"Capture\")\n                }\n            }\n\n            is CameraKState.Error -&gt; {\n                Text(\n                    text = \"Camera Error: ${(cameraState as CameraKState.Error).exception.message}\",\n                    modifier = Modifier.align(Alignment.Center)\n                )\n            }\n\n            CameraKState.Initializing -&gt; {\n                CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))\n            }\n        }\n    }\n}\n</code></pre> <p>That's it! You now have a working camera app.</p>"},{"location":"getting-started/quick-start/#alternative-using-camerakscreen","title":"Alternative: Using <code>CameraKScreen</code>","text":"<p>For even less boilerplate, use the <code>CameraKScreen</code> helper that handles state automatically:</p> <pre><code>@Composable\nfun SimpleCameraScreen() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val cameraState by rememberCameraKState(permissions = permissions).cameraState.collectAsStateWithLifecycle()\n\n    CameraKScreen(\n        cameraState = cameraState,\n        showPreview = true,\n        loadingContent = {\n            // Optional: Custom loading UI\n            CircularProgressIndicator()\n        },\n        errorContent = { error -&gt;\n            // Optional: Custom error UI\n            Text(\"Camera Error: ${error.message}\")\n        }\n    ) { readyState -&gt;\n        // Camera preview is shown automatically\n        // Add your UI overlay here\n        FloatingActionButton(\n            onClick = {\n                scope.launch {\n                    readyState.controller.takePictureToFile()\n                }\n            },\n            modifier = Modifier\n                .fillMaxSize()\n                .wrapContentSize(Alignment.BottomCenter)\n                .padding(32.dp)\n        ) {\n            Icon(Icons.Default.CameraAlt, contentDescription = \"Capture\")\n        }\n    }\n}\n</code></pre> <p>Benefits: - \u2705 Automatic state handling (no when expression needed) - \u2705 Built-in loading and error screens - \u2705 Camera preview shown automatically - \u2705 Less boilerplate code</p>"},{"location":"getting-started/quick-start/#whats-happening","title":"What's Happening?","text":""},{"location":"getting-started/quick-start/#1-permission-handling","title":"1. Permission Handling","text":"<pre><code>val permissions = providePermissions()\n</code></pre> <p>Provides platform-specific permission controller. Automatically requests camera permissions on first use.</p>"},{"location":"getting-started/quick-start/#2-camera-state-management","title":"2. Camera State Management","text":"<pre><code>val stateHolder = rememberCameraKState(permissions = permissions)\nval cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n</code></pre> <p>Creates a state holder that manages camera lifecycle. State flows through: - <code>Initializing</code> \u2192 Camera starting - <code>Ready</code> \u2192 Camera operational - <code>Error</code> \u2192 Something went wrong</p>"},{"location":"getting-started/quick-start/#3-camera-preview","title":"3. Camera Preview","text":"<pre><code>CameraPreviewComposable(\n    controller = controller,\n    modifier = Modifier.fillMaxSize()\n)\n</code></pre> <p>Displays live camera feed. Only available when state is <code>Ready</code>.</p>"},{"location":"getting-started/quick-start/#4-capture-photos","title":"4. Capture Photos","text":"<pre><code>when (val result = controller.takePictureToFile()) {\n    is ImageCaptureResult.SuccessWithFile -&gt; {\n        // result.filePath contains the saved image path\n    }\n    is ImageCaptureResult.Error -&gt; {\n        // result.exception contains the error\n    }\n}\n</code></pre> <p>Captures and saves photo directly to file. Returns sealed class with type-safe results.</p>"},{"location":"getting-started/quick-start/#add-flash-control","title":"Add Flash Control","text":"<pre><code>@Composable\nfun CameraScreenWithFlash() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                // Flash toggle button\n                IconButton(\n                    onClick = { controller.toggleFlashMode() },\n                    modifier = Modifier\n                        .align(Alignment.TopEnd)\n                        .padding(16.dp)\n                ) {\n                    Icon(\n                        imageVector = when (controller.getFlashMode()) {\n                            FlashMode.ON -&gt; Icons.Default.FlashOn\n                            FlashMode.OFF -&gt; Icons.Default.FlashOff\n                            FlashMode.AUTO -&gt; Icons.Default.FlashAuto\n                            else -&gt; Icons.Default.FlashOff\n                        },\n                        contentDescription = \"Flash\"\n                    )\n                }\n\n                // Capture button\n                FloatingActionButton(\n                    onClick = {\n                        scope.launch {\n                            controller.takePictureToFile()\n                        }\n                    },\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(16.dp)\n                ) {\n                    Icon(Icons.Default.CameraAlt, contentDescription = \"Capture\")\n                }\n            }\n\n            is CameraKState.Error -&gt; {\n                Text(\"Error: ${(cameraState as CameraKState.Error).exception.message}\")\n            }\n\n            CameraKState.Initializing -&gt; {\n                CircularProgressIndicator()\n            }\n        }\n    }\n}\n</code></pre> <p>New: <code>toggleFlashMode()</code> cycles through OFF \u2192 ON \u2192 AUTO.</p>"},{"location":"getting-started/quick-start/#add-camera-switching","title":"Add Camera Switching","text":"<pre><code>@Composable\nfun CameraScreenWithSwitching() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                Row(\n                    modifier = Modifier\n                        .align(Alignment.TopEnd)\n                        .padding(16.dp),\n                    horizontalArrangement = Arrangement.spacedBy(8.dp)\n                ) {\n                    // Flash toggle\n                    IconButton(onClick = { controller.toggleFlashMode() }) {\n                        Icon(Icons.Default.FlashOn, contentDescription = \"Flash\")\n                    }\n\n                    // Camera switch\n                    IconButton(onClick = { controller.toggleCameraLens() }) {\n                        Icon(Icons.Default.Cameraswitch, contentDescription = \"Switch Camera\")\n                    }\n                }\n\n                // Capture button\n                FloatingActionButton(\n                    onClick = {\n                        scope.launch {\n                            controller.takePictureToFile()\n                        }\n                    },\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(16.dp)\n                ) {\n                    Icon(Icons.Default.CameraAlt, contentDescription = \"Capture\")\n                }\n            }\n\n            is CameraKState.Error -&gt; {\n                Text(\"Error: ${(cameraState as CameraKState.Error).exception.message}\")\n            }\n\n            CameraKState.Initializing -&gt; {\n                CircularProgressIndicator()\n            }\n        }\n    }\n}\n</code></pre> <p>New: <code>toggleCameraLens()</code> switches between front and back cameras.</p>"},{"location":"getting-started/quick-start/#configuration-options","title":"Configuration Options","text":"<p>Customize camera behavior during initialization:</p> <pre><code>val stateHolder = rememberCameraKState(\n    permissions = permissions,\n    cameraConfiguration = {\n        setCameraLens(CameraLens.FRONT)           // Start with front camera\n        setFlashMode(FlashMode.OFF)               // Flash off by default\n        setAspectRatio(AspectRatio.RATIO_16_9)    // 16:9 widescreen\n        setImageFormat(ImageFormat.JPEG)          // JPEG compression\n        setDirectory(Directory.PICTURES)          // Save to Pictures folder\n    }\n)\n</code></pre> <p>See Configuration Guide for all options.</p>"},{"location":"getting-started/quick-start/#add-plugins","title":"Add Plugins","text":"<p>Enable QR scanning or OCR:</p> <pre><code>val stateHolder = rememberCameraKState(\n    permissions = permissions,\n    plugins = listOf(\n        rememberQRScannerPlugin(),\n        rememberOcrPlugin()\n    )\n)\n\n// Access scanned QR codes\nval qrCodes by stateHolder.qrCodeFlow.collectAsStateWithLifecycle(initial = emptyList())\n\n// Access recognized text\nval recognizedText by stateHolder.recognizedTextFlow.collectAsStateWithLifecycle(initial = \"\")\n</code></pre> <p>See Plugins Guide for details.</p>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration \u2014 Customize camera settings</li> <li>CameraKScreen API \u2014 Convenience wrapper with automatic state handling</li> <li>CameraKStateHolder API \u2014 State management details</li> <li>CameraController API \u2014 Low-level camera operations</li> <li>Camera Capture Guide \u2014 Advanced capture techniques</li> <li>Flash and Torch \u2014 Lighting control</li> <li>Zoom Control \u2014 Pinch-to-zoom</li> <li>Plugins \u2014 Extend functionality</li> </ul>"},{"location":"guides/camera-capture/","title":"Camera Capture","text":"<p>Capture photos with type-safe result handling.</p>"},{"location":"guides/camera-capture/#basic-capture","title":"Basic Capture","text":"<pre><code>@Composable\nfun CaptureExample() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n\n    when (cameraState) {\n        is CameraKState.Ready -&gt; {\n            val controller = (cameraState as CameraKState.Ready).controller\n\n            Button(onClick = {\n                scope.launch {\n                    when (val result = controller.takePictureToFile()) {\n                        is ImageCaptureResult.SuccessWithFile -&gt; {\n                            println(\"Saved to: ${result.filePath}\")\n                        }\n                        is ImageCaptureResult.Error -&gt; {\n                            println(\"Error: ${result.exception.message}\")\n                        }\n                    }\n                }\n            }) {\n                Text(\"Capture Photo\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"guides/camera-capture/#recommended-takepicturetofile","title":"Recommended: <code>takePictureToFile()</code>","text":"<p>Fast, efficient direct file capture \u2014 saves directly to disk without memory overhead.</p> <pre><code>suspend fun takePictureToFile(): ImageCaptureResult\n</code></pre> <p>Returns: - <code>ImageCaptureResult.SuccessWithFile(filePath: String)</code> - <code>ImageCaptureResult.Error(exception: Exception)</code></p> <p>Benefits: - \u26a1 2-3 seconds faster than <code>takePicture()</code> - \ud83d\udcbe No ByteArray conversion \u2014 direct disk write - \ud83e\udde0 Lower memory usage \u2014 no decode/encode cycles</p> <p>Example with error handling:</p> <pre><code>scope.launch {\n    try {\n        when (val result = controller.takePictureToFile()) {\n            is ImageCaptureResult.SuccessWithFile -&gt; {\n                val file = File(result.filePath)\n                println(\"Photo saved: ${file.absolutePath}\")\n                println(\"File size: ${file.length()} bytes\")\n\n                // Load into image viewer\n                loadImage(result.filePath)\n            }\n            is ImageCaptureResult.Error -&gt; {\n                showError(\"Capture failed: ${result.exception.message}\")\n            }\n        }\n    } catch (e: CancellationException) {\n        println(\"Capture was cancelled\")\n        throw e  // Re-throw cancellation\n    }\n}\n</code></pre>"},{"location":"guides/camera-capture/#legacy-takepicture","title":"Legacy: <code>takePicture()</code>","text":"<p>Deprecated \u2014 Returns image as <code>ByteArray</code>. Use <code>takePictureToFile()</code> instead.</p> <pre><code>@Deprecated(\"Use takePictureToFile() for better performance\")\nsuspend fun takePicture(): ImageCaptureResult\n</code></pre> <p>Returns: - <code>ImageCaptureResult.Success(byteArray: ByteArray)</code> - <code>ImageCaptureResult.Error(exception: Exception)</code></p> <p>Only use if: - You need to process the image in memory before saving - You're uploading directly to a server without saving locally - You're applying immediate image transformations</p> <p>Example:</p> <pre><code>scope.launch {\n    when (val result = controller.takePicture()) {\n        is ImageCaptureResult.Success -&gt; {\n            val imageData = result.byteArray\n            uploadToServer(imageData)\n        }\n        is ImageCaptureResult.Error -&gt; {\n            showError(result.exception.message)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/camera-capture/#result-types","title":"Result Types","text":"<p>Sealed class ensures exhaustive pattern matching:</p> <pre><code>sealed class ImageCaptureResult {\n    data class SuccessWithFile(val filePath: String) : ImageCaptureResult()\n    data class Success(val byteArray: ByteArray) : ImageCaptureResult()\n    data class Error(val exception: Exception) : ImageCaptureResult()\n}\n</code></pre> <p>Handle all cases:</p> <pre><code>when (result) {\n    is ImageCaptureResult.SuccessWithFile -&gt; {\n        // File saved, path available\n        val path = result.filePath\n    }\n    is ImageCaptureResult.Success -&gt; {\n        // ByteArray available (deprecated path)\n        val data = result.byteArray\n    }\n    is ImageCaptureResult.Error -&gt; {\n        // Error occurred\n        val error = result.exception\n    }\n}\n</code></pre>"},{"location":"guides/camera-capture/#capture-with-ui-feedback","title":"Capture with UI Feedback","text":"<p>Show loading state during capture:</p> <pre><code>@Composable\nfun CaptureWithFeedback() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    var isCapturing by remember { mutableStateOf(false) }\n    var lastCapturedPath by remember { mutableStateOf&lt;String?&gt;(null) }\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                // Capture button with loading\n                FloatingActionButton(\n                    onClick = {\n                        scope.launch {\n                            isCapturing = true\n                            when (val result = controller.takePictureToFile()) {\n                                is ImageCaptureResult.SuccessWithFile -&gt; {\n                                    lastCapturedPath = result.filePath\n                                }\n                                is ImageCaptureResult.Error -&gt; {\n                                    println(\"Error: ${result.exception.message}\")\n                                }\n                            }\n                            isCapturing = false\n                        }\n                    },\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(32.dp)\n                ) {\n                    if (isCapturing) {\n                        CircularProgressIndicator(\n                            color = Color.White,\n                            modifier = Modifier.size(24.dp)\n                        )\n                    } else {\n                        Icon(Icons.Default.CameraAlt, \"Capture\")\n                    }\n                }\n\n                // Show thumbnail of last capture\n                lastCapturedPath?.let { path -&gt;\n                    AsyncImage(\n                        model = path,\n                        contentDescription = \"Last capture\",\n                        modifier = Modifier\n                            .align(Alignment.BottomStart)\n                            .padding(16.dp)\n                            .size(64.dp)\n                            .clip(RoundedCornerShape(8.dp))\n                    )\n                }\n            }\n\n            is CameraKState.Error -&gt; Text(\"Camera error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/camera-capture/#burst-capture","title":"Burst Capture","text":"<p>Capture multiple photos quickly:</p> <pre><code>fun captureBurst(controller: CameraController, count: Int) {\n    val scope = CoroutineScope(Dispatchers.Default)\n\n    scope.launch {\n        val results = mutableListOf&lt;String&gt;()\n\n        repeat(count) { index -&gt;\n            when (val result = controller.takePictureToFile()) {\n                is ImageCaptureResult.SuccessWithFile -&gt; {\n                    results.add(result.filePath)\n                    println(\"Captured ${index + 1}/$count\")\n                }\n                is ImageCaptureResult.Error -&gt; {\n                    println(\"Burst failed at ${index + 1}: ${result.exception.message}\")\n                    return@launch\n                }\n            }\n\n            // Small delay between captures\n            delay(100)\n        }\n\n        println(\"Burst complete: ${results.size} photos\")\n    }\n}\n</code></pre> <p>Limitations: - Maximum 3 concurrent captures (queued automatically) - Rapid captures may reduce quality on some devices - Memory pressure increases with burst count</p>"},{"location":"guides/camera-capture/#capture-with-flash-control","title":"Capture with Flash Control","text":"<p>Toggle flash before capture:</p> <pre><code>Button(onClick = {\n    scope.launch {\n        // Enable flash\n        controller.setFlashMode(FlashMode.ON)\n\n        // Capture with flash\n        val result = controller.takePictureToFile()\n\n        // Disable flash\n        controller.setFlashMode(FlashMode.OFF)\n\n        when (result) {\n            is ImageCaptureResult.SuccessWithFile -&gt; {\n                println(\"Flash photo: ${result.filePath}\")\n            }\n            is ImageCaptureResult.Error -&gt; {\n                println(\"Error: ${result.exception.message}\")\n            }\n        }\n    }\n}) {\n    Text(\"Capture with Flash\")\n}\n</code></pre>"},{"location":"guides/camera-capture/#save-to-custom-location","title":"Save to Custom Location","text":"<p>By default, images save to the configured directory. To customize:</p> <pre><code>// Configure save directory\nval stateHolder = rememberCameraKState(\n    permissions = permissions,\n    cameraConfiguration = {\n        setDirectory(Directory.DOWNLOADS)  // Save to Downloads\n    }\n)\n</code></pre> <p>Options: - <code>Directory.PICTURES</code> \u2014 User pictures (default) - <code>Directory.DCIM</code> \u2014 Camera roll - <code>Directory.DOWNLOADS</code> \u2014 Downloads folder - <code>Directory.DOCUMENTS</code> \u2014 Documents - <code>Directory.CACHE</code> \u2014 Temporary cache</p> <p>File naming: Files are automatically named with timestamp: <pre><code>IMG_20240129_143022.jpg\n</code></pre></p>"},{"location":"guides/camera-capture/#error-handling","title":"Error Handling","text":"<p>Handle common error scenarios:</p> <pre><code>scope.launch {\n    when (val result = controller.takePictureToFile()) {\n        is ImageCaptureResult.SuccessWithFile -&gt; {\n            handleSuccess(result.filePath)\n        }\n        is ImageCaptureResult.Error -&gt; {\n            when (result.exception) {\n                is IOException -&gt; {\n                    // Storage full or permission issue\n                    showError(\"Cannot save photo: storage issue\")\n                }\n                is IllegalStateException -&gt; {\n                    // Camera not ready\n                    showError(\"Camera not ready, try again\")\n                }\n                is CancellationException -&gt; {\n                    // User cancelled\n                    println(\"Capture cancelled\")\n                }\n                else -&gt; {\n                    // Unknown error\n                    showError(\"Capture failed: ${result.exception.message}\")\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"guides/camera-capture/#common-issues","title":"Common Issues","text":""},{"location":"guides/camera-capture/#camera-not-initialized","title":"\"Camera not initialized\"","text":"<p>Cause: Attempting capture before camera is ready.</p> <p>Solution: Only capture when state is <code>Ready</code>:</p> <pre><code>when (cameraState) {\n    is CameraKState.Ready -&gt; {\n        // Safe to capture\n        controller.takePictureToFile()\n    }\n    else -&gt; {\n        println(\"Camera not ready\")\n    }\n}\n</code></pre>"},{"location":"guides/camera-capture/#storage-permission-denied-android","title":"\"Storage permission denied\" (Android)","text":"<p>Cause: Missing storage permission on Android &lt; 10.</p> <p>Solution: Add permission to manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"\n    android:maxSdkVersion=\"28\" /&gt;\n</code></pre>"},{"location":"guides/camera-capture/#burst-queue-full","title":"\"Burst queue full\"","text":"<p>Cause: Too many concurrent capture requests.</p> <p>Solution: Limit to 3 concurrent captures or wait for completion:</p> <pre><code>scope.launch {\n    val result1 = controller.takePictureToFile()\n    // Wait for first to complete before next\n    val result2 = controller.takePictureToFile()\n}\n</code></pre>"},{"location":"guides/camera-capture/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use <code>takePictureToFile()</code> \u2014 2-3x faster than <code>takePicture()</code></li> <li>Lower resolution \u2014 Set <code>setResolution(1920 to 1080)</code> for faster capture</li> <li>JPEG format \u2014 Faster than PNG</li> <li>Quality prioritization \u2014 Use <code>QualityPrioritization.SPEED</code> for rapid capture</li> <li>Avoid burst on low-end devices \u2014 Limit to 3-5 photos</li> </ol>"},{"location":"guides/camera-capture/#next-steps","title":"Next Steps","text":"<ul> <li>Flash and Torch \u2014 Control camera lighting</li> <li>Zoom Control \u2014 Implement zoom functionality</li> <li>CameraController API \u2014 Full API reference</li> </ul>"},{"location":"guides/camera-switching/","title":"Camera Switching","text":"<p>Switch between front and back cameras.</p>"},{"location":"guides/camera-switching/#toggle-camera-lens","title":"Toggle Camera Lens","text":"<p>Switch between front and back cameras:</p> <pre><code>controller.toggleCameraLens()  // BACK \u2194 FRONT\n</code></pre>"},{"location":"guides/camera-switching/#set-specific-camera","title":"Set Specific Camera","text":"<pre><code>controller.setCameraLens(CameraLens.FRONT)  // Front camera\ncontroller.setCameraLens(CameraLens.BACK)   // Back camera\n</code></pre>"},{"location":"guides/camera-switching/#get-current-camera","title":"Get Current Camera","text":"<pre><code>val currentLens = controller.getCameraLens()\nwhen (currentLens) {\n    CameraLens.FRONT -&gt; println(\"Using front camera\")\n    CameraLens.BACK -&gt; println(\"Using back camera\")\n    null -&gt; println(\"Camera not initialized\")\n}\n</code></pre>"},{"location":"guides/camera-switching/#ui-example","title":"UI Example","text":"<pre><code>@Composable\nfun CameraWithSwitching() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                // Camera switch button\n                IconButton(\n                    onClick = { controller.toggleCameraLens() },\n                    modifier = Modifier\n                        .align(Alignment.TopEnd)\n                        .padding(16.dp)\n                        .background(Color.Black.copy(alpha = 0.5f), CircleShape)\n                ) {\n                    Icon(\n                        imageVector = Icons.Default.Cameraswitch,\n                        contentDescription = \"Switch Camera\",\n                        tint = Color.White\n                    )\n                }\n\n                // Capture button\n                FloatingActionButton(\n                    onClick = {\n                        scope.launch {\n                            controller.takePictureToFile()\n                        }\n                    },\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(32.dp)\n                ) {\n                    Icon(Icons.Default.CameraAlt, \"Capture\")\n                }\n            }\n\n            is CameraKState.Error -&gt; Text(\"Camera error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/camera-switching/#configuration-set-initial-camera","title":"Configuration: Set Initial Camera","text":"<pre><code>val stateHolder = rememberCameraKState(\n    permissions = permissions,\n    cameraConfiguration = {\n        setCameraLens(CameraLens.FRONT)  // Start with selfie camera\n    }\n)\n</code></pre>"},{"location":"guides/camera-switching/#smooth-camera-switch","title":"Smooth Camera Switch","text":"<p>Add loading indicator during switch:</p> <pre><code>@Composable\nfun CameraWithSmoothSwitch() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    var isSwitching by remember { mutableStateOf(false) }\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                // Switch button\n                IconButton(\n                    onClick = {\n                        scope.launch {\n                            isSwitching = true\n                            delay(100)  // Brief delay for smooth animation\n                            controller.toggleCameraLens()\n                            delay(300)  // Wait for camera switch\n                            isSwitching = false\n                        }\n                    },\n                    enabled = !isSwitching,\n                    modifier = Modifier\n                        .align(Alignment.TopEnd)\n                        .padding(16.dp)\n                        .background(Color.Black.copy(alpha = 0.5f), CircleShape)\n                ) {\n                    if (isSwitching) {\n                        CircularProgressIndicator(\n                            modifier = Modifier.size(24.dp),\n                            color = Color.White,\n                            strokeWidth = 2.dp\n                        )\n                    } else {\n                        Icon(\n                            imageVector = Icons.Default.Cameraswitch,\n                            contentDescription = \"Switch Camera\",\n                            tint = Color.White\n                        )\n                    }\n                }\n            }\n\n            is CameraKState.Error -&gt; Text(\"Camera error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/camera-switching/#platform-specific-behavior","title":"Platform-Specific Behavior","text":""},{"location":"guides/camera-switching/#android","title":"Android","text":"<ul> <li>Seamless switching via CameraX</li> <li>Preview may pause briefly (&lt;100ms)</li> <li>Flash settings reset per camera</li> </ul>"},{"location":"guides/camera-switching/#ios","title":"iOS","text":"<ul> <li>Swift AVFoundation switch</li> <li>Preview updates smoothly</li> <li>Flash/torch settings persist per camera</li> </ul>"},{"location":"guides/camera-switching/#desktop","title":"Desktop","text":"<ul> <li>Requires multiple webcams</li> <li>Switching cycles through available devices</li> <li>Single webcam: no effect</li> </ul>"},{"location":"guides/camera-switching/#preserve-settings-after-switch","title":"Preserve Settings After Switch","text":"<p>Save and restore settings:</p> <pre><code>fun switchCameraPreserveSettings(controller: CameraController) {\n    // Save current settings\n    val savedFlashMode = controller.getFlashMode()\n    val savedZoom = controller.getZoom()\n\n    // Switch camera\n    controller.toggleCameraLens()\n\n    // Wait for switch to complete\n    scope.launch {\n        delay(200)\n\n        // Restore settings (if supported on new camera)\n        savedFlashMode?.let { controller.setFlashMode(it) }\n        controller.setZoom(savedZoom.coerceIn(1f, controller.getMaxZoom()))\n    }\n}\n</code></pre>"},{"location":"guides/camera-switching/#disable-flash-when-switching-to-front","title":"Disable Flash When Switching to Front","text":"<p>Most front cameras don't have flash:</p> <pre><code>fun switchToFront(controller: CameraController) {\n    controller.setCameraLens(CameraLens.FRONT)\n    controller.setFlashMode(FlashMode.OFF)  // Disable flash\n}\n\nfun switchToBack(controller: CameraController) {\n    controller.setCameraLens(CameraLens.BACK)\n    controller.setFlashMode(FlashMode.AUTO)  // Re-enable flash\n}\n</code></pre>"},{"location":"guides/camera-switching/#animated-camera-icon","title":"Animated Camera Icon","text":"<p>Show which camera is active:</p> <pre><code>@Composable\nfun AnimatedCameraSwitch() {\n    val permissions = providePermissions()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    var isFrontCamera by remember { mutableStateOf(false) }\n    val rotation by animateFloatAsState(\n        targetValue = if (isFrontCamera) 180f else 0f,\n        animationSpec = tween(durationMillis = 300)\n    )\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                IconButton(\n                    onClick = {\n                        controller.toggleCameraLens()\n                        isFrontCamera = !isFrontCamera\n                    },\n                    modifier = Modifier\n                        .align(Alignment.TopEnd)\n                        .padding(16.dp)\n                        .background(Color.Black.copy(alpha = 0.5f), CircleShape)\n                ) {\n                    Icon(\n                        imageVector = Icons.Default.Cameraswitch,\n                        contentDescription = \"Switch Camera\",\n                        tint = Color.White,\n                        modifier = Modifier.graphicsLayer { rotationY = rotation }\n                    )\n                }\n            }\n\n            is CameraKState.Error -&gt; Text(\"Camera error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/camera-switching/#common-issues","title":"Common Issues","text":""},{"location":"guides/camera-switching/#preview-freezes-after-switch","title":"Preview Freezes After Switch","text":"<p>Cause: Camera needs time to reinitialize.</p> <p>Solution: Add small delay after switch:</p> <pre><code>controller.toggleCameraLens()\ndelay(300)\n// Camera ready\n</code></pre>"},{"location":"guides/camera-switching/#flash-doesnt-work-after-switching","title":"Flash Doesn't Work After Switching","text":"<p>Cause: Front cameras usually lack flash.</p> <p>Solution: Disable flash UI for front camera:</p> <pre><code>val currentLens = controller.getCameraLens()\nval showFlashButton = currentLens == CameraLens.BACK\n</code></pre>"},{"location":"guides/camera-switching/#settings-dont-persist","title":"Settings Don't Persist","text":"<p>Cause: Each camera has independent settings.</p> <p>Solution: Store settings externally and reapply after switch.</p>"},{"location":"guides/camera-switching/#best-practices","title":"Best Practices","text":"<ol> <li>Disable button during switch \u2014 Prevent multiple rapid switches</li> <li>Show loading indicator \u2014 Provide visual feedback</li> <li>Reset zoom \u2014 Front camera may have different zoom range</li> <li>Disable flash for front camera \u2014 Avoid confusion</li> <li>Test on real devices \u2014 Emulators have limited camera support</li> </ol>"},{"location":"guides/camera-switching/#next-steps","title":"Next Steps","text":"<ul> <li>Flash and Torch \u2014 Control lighting per camera</li> <li>Zoom Control \u2014 Handle different zoom ranges</li> <li>Configuration \u2014 Set initial camera</li> </ul>"},{"location":"guides/flash-and-torch/","title":"Flash and Torch Control","text":"<p>Control camera flash for photos and torch for continuous light.</p>"},{"location":"guides/flash-and-torch/#flash-modes","title":"Flash Modes","text":"<p>Flash fires when capturing photos.</p>"},{"location":"guides/flash-and-torch/#set-flash-mode","title":"Set Flash Mode","text":"<pre><code>controller.setFlashMode(FlashMode.ON)\n</code></pre> <p>Options: - <code>FlashMode.OFF</code> \u2014 Flash disabled - <code>FlashMode.ON</code> \u2014 Flash always fires - <code>FlashMode.AUTO</code> \u2014 Flash fires in low light</p>"},{"location":"guides/flash-and-torch/#toggle-flash-mode","title":"Toggle Flash Mode","text":"<p>Cycle through modes: OFF \u2192 ON \u2192 AUTO \u2192 OFF</p> <pre><code>controller.toggleFlashMode()\n</code></pre>"},{"location":"guides/flash-and-torch/#get-current-mode","title":"Get Current Mode","text":"<pre><code>val currentMode = controller.getFlashMode()\nwhen (currentMode) {\n    FlashMode.ON -&gt; println(\"Flash is enabled\")\n    FlashMode.OFF -&gt; println(\"Flash is disabled\")\n    FlashMode.AUTO -&gt; println(\"Flash is automatic\")\n    null -&gt; println(\"Flash not available\")\n}\n</code></pre>"},{"location":"guides/flash-and-torch/#flash-ui-example","title":"Flash UI Example","text":"<pre><code>@Composable\nfun CameraWithFlash() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    var flashMode by remember { mutableStateOf(FlashMode.OFF) }\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                // Flash toggle button\n                IconButton(\n                    onClick = {\n                        controller.toggleFlashMode()\n                        flashMode = controller.getFlashMode() ?: FlashMode.OFF\n                    },\n                    modifier = Modifier\n                        .align(Alignment.TopEnd)\n                        .padding(16.dp)\n                        .background(Color.Black.copy(alpha = 0.5f), CircleShape)\n                ) {\n                    Icon(\n                        imageVector = when (flashMode) {\n                            FlashMode.ON -&gt; Icons.Default.FlashOn\n                            FlashMode.OFF -&gt; Icons.Default.FlashOff\n                            FlashMode.AUTO -&gt; Icons.Default.FlashAuto\n                        },\n                        contentDescription = \"Flash: $flashMode\",\n                        tint = Color.White\n                    )\n                }\n\n                // Capture button\n                FloatingActionButton(\n                    onClick = {\n                        scope.launch {\n                            controller.takePictureToFile()\n                        }\n                    },\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(32.dp)\n                ) {\n                    Icon(Icons.Default.CameraAlt, \"Capture\")\n                }\n            }\n\n            is CameraKState.Error -&gt; Text(\"Camera error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/flash-and-torch/#torch-mode","title":"Torch Mode","text":"<p>Torch provides continuous light (flashlight mode).</p>"},{"location":"guides/flash-and-torch/#toggle-torch","title":"Toggle Torch","text":"<pre><code>controller.toggleTorchMode()  // ON \u2194 OFF\n</code></pre>"},{"location":"guides/flash-and-torch/#set-torch-mode","title":"Set Torch Mode","text":"<pre><code>controller.setTorchMode(TorchMode.ON)\n</code></pre> <p>Options: - <code>TorchMode.ON</code> \u2014 Torch enabled - <code>TorchMode.OFF</code> \u2014 Torch disabled</p>"},{"location":"guides/flash-and-torch/#get-torch-state","title":"Get Torch State","text":"<pre><code>val torchState = controller.getTorchMode()\nwhen (torchState) {\n    TorchMode.ON -&gt; println(\"Torch is on\")\n    TorchMode.OFF -&gt; println(\"Torch is off\")\n    null -&gt; println(\"Torch not available\")\n}\n</code></pre>"},{"location":"guides/flash-and-torch/#torch-ui-example","title":"Torch UI Example","text":"<pre><code>@Composable\nfun CameraWithTorch() {\n    val permissions = providePermissions()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    var isTorchOn by remember { mutableStateOf(false) }\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                // Torch toggle\n                IconButton(\n                    onClick = {\n                        controller.toggleTorchMode()\n                        isTorchOn = controller.getTorchMode() == TorchMode.ON\n                    },\n                    modifier = Modifier\n                        .align(Alignment.TopStart)\n                        .padding(16.dp)\n                        .background(\n                            if (isTorchOn) Color.Yellow.copy(alpha = 0.7f)\n                            else Color.Black.copy(alpha = 0.5f),\n                            CircleShape\n                        )\n                ) {\n                    Icon(\n                        imageVector = if (isTorchOn) Icons.Default.FlashlightOn \n                                      else Icons.Default.FlashlightOff,\n                        contentDescription = if (isTorchOn) \"Turn off torch\" else \"Turn on torch\",\n                        tint = if (isTorchOn) Color.Black else Color.White\n                    )\n                }\n            }\n\n            is CameraKState.Error -&gt; Text(\"Camera error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/flash-and-torch/#flash-vs-torch","title":"Flash vs Torch","text":"Feature Flash Torch Use case Photo capture Continuous light Activation Fires during capture Manual toggle Duration Brief burst Stays on until disabled Battery impact Minimal High (use sparingly) API <code>setFlashMode()</code> <code>setTorchMode()</code> <p>Best practices: - Use flash for taking photos - Use torch for video recording or low-light navigation - Turn off torch when not needed to save battery</p>"},{"location":"guides/flash-and-torch/#combined-flash-and-torch-ui","title":"Combined Flash and Torch UI","text":"<pre><code>@Composable\nfun CameraWithLighting() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    var flashMode by remember { mutableStateOf(FlashMode.AUTO) }\n    var isTorchOn by remember { mutableStateOf(false) }\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                // Controls at top\n                Row(\n                    modifier = Modifier\n                        .align(Alignment.TopCenter)\n                        .padding(16.dp)\n                        .background(Color.Black.copy(alpha = 0.5f), RoundedCornerShape(24.dp))\n                        .padding(horizontal = 8.dp),\n                    horizontalArrangement = Arrangement.spacedBy(8.dp)\n                ) {\n                    // Flash mode\n                    IconButton(onClick = {\n                        controller.toggleFlashMode()\n                        flashMode = controller.getFlashMode() ?: FlashMode.AUTO\n                    }) {\n                        Icon(\n                            imageVector = when (flashMode) {\n                                FlashMode.ON -&gt; Icons.Default.FlashOn\n                                FlashMode.OFF -&gt; Icons.Default.FlashOff\n                                FlashMode.AUTO -&gt; Icons.Default.FlashAuto\n                            },\n                            contentDescription = \"Flash: $flashMode\",\n                            tint = Color.White\n                        )\n                    }\n\n                    // Torch toggle\n                    IconButton(onClick = {\n                        controller.toggleTorchMode()\n                        isTorchOn = controller.getTorchMode() == TorchMode.ON\n                    }) {\n                        Icon(\n                            imageVector = if (isTorchOn) Icons.Default.FlashlightOn\n                                          else Icons.Default.FlashlightOff,\n                            contentDescription = \"Torch\",\n                            tint = if (isTorchOn) Color.Yellow else Color.White\n                        )\n                    }\n                }\n\n                // Capture button\n                FloatingActionButton(\n                    onClick = {\n                        scope.launch {\n                            controller.takePictureToFile()\n                        }\n                    },\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(32.dp)\n                ) {\n                    Icon(Icons.Default.CameraAlt, \"Capture\")\n                }\n            }\n\n            is CameraKState.Error -&gt; Text(\"Camera error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/flash-and-torch/#configuration-set-default-flash-mode","title":"Configuration: Set Default Flash Mode","text":"<p>Set initial flash mode during setup:</p> <pre><code>val stateHolder = rememberCameraKState(\n    permissions = permissions,\n    cameraConfiguration = {\n        setFlashMode(FlashMode.OFF)  // Start with flash disabled\n    }\n)\n</code></pre>"},{"location":"guides/flash-and-torch/#platform-availability","title":"Platform Availability","text":""},{"location":"guides/flash-and-torch/#android","title":"Android","text":"<ul> <li>\u2705 Flash: Available on rear cameras</li> <li>\u2705 Torch: Available on rear cameras</li> <li>\u274c Front camera: Usually no flash/torch</li> </ul>"},{"location":"guides/flash-and-torch/#ios","title":"iOS","text":"<ul> <li>\u2705 Flash: Available on rear cameras</li> <li>\u2705 Torch: Available on rear cameras  </li> <li>\u274c Front camera: iPhone 12+ has \"Retina Flash\" (screen flash)</li> </ul>"},{"location":"guides/flash-and-torch/#desktop","title":"Desktop","text":"<ul> <li>\u274c Flash: Not available</li> <li>\u274c Torch: Not available</li> </ul> <p>Check availability:</p> <pre><code>val flashMode = controller.getFlashMode()\nif (flashMode != null) {\n    // Flash is available\n} else {\n    // No flash on this camera\n}\n</code></pre>"},{"location":"guides/flash-and-torch/#common-issues","title":"Common Issues","text":""},{"location":"guides/flash-and-torch/#flash-not-working","title":"Flash Not Working","text":"<p>Cause: Front camera selected (no flash hardware).</p> <p>Solution: Switch to rear camera:</p> <pre><code>controller.setCameraLens(CameraLens.BACK)\n</code></pre>"},{"location":"guides/flash-and-torch/#torch-stays-on-after-closing-app","title":"Torch Stays On After Closing App","text":"<p>Cause: Torch not disabled in cleanup.</p> <p>Solution: Disable torch when leaving camera:</p> <pre><code>DisposableEffect(Unit) {\n    onDispose {\n        controller.setTorchMode(TorchMode.OFF)\n        controller.cleanup()\n    }\n}\n</code></pre>"},{"location":"guides/flash-and-torch/#flash-mode-resets-when-switching-cameras","title":"Flash Mode Resets When Switching Cameras","text":"<p>Cause: Each camera has independent flash settings.</p> <p>Solution: Re-apply flash mode after switching:</p> <pre><code>controller.toggleCameraLens()\ncontroller.setFlashMode(FlashMode.ON)  // Re-apply\n</code></pre>"},{"location":"guides/flash-and-torch/#best-practices","title":"Best Practices","text":"<ol> <li>Save battery \u2014 Turn off torch when not actively needed</li> <li>User feedback \u2014 Show visual indicator when torch is on</li> <li>Cleanup \u2014 Always disable torch in <code>onDispose</code> or app background</li> <li>Test on device \u2014 Emulators don't have flash/torch</li> <li>Front camera \u2014 Disable flash UI when front camera active</li> </ol>"},{"location":"guides/flash-and-torch/#next-steps","title":"Next Steps","text":"<ul> <li>Zoom Control \u2014 Implement zoom functionality</li> <li>Camera Switching \u2014 Switch between cameras</li> <li>Configuration \u2014 Default flash settings</li> </ul>"},{"location":"guides/plugins/","title":"Plugins","text":"<p>Extend CameraK with modular plugins for QR scanning, OCR, and custom processing.</p>"},{"location":"guides/plugins/#overview","title":"Overview","text":"<p>Plugins extend camera functionality without modifying core camera code. They auto-activate when camera becomes ready and process frames in the background.</p> <p>Built-in plugins: - QR Scanner \u2014 Scan QR codes and barcodes - OCR \u2014 Recognize text in camera feed - Image Saver \u2014 Auto-save captured images with custom processing</p>"},{"location":"guides/plugins/#using-plugins","title":"Using Plugins","text":"<p>Add plugins during initialization:</p> <pre><code>val stateHolder = rememberCameraKState(\n    permissions = permissions,\n    plugins = listOf(\n        rememberQRScannerPlugin(),\n        rememberOcrPlugin(),\n        rememberImageSaverPlugin()\n    )\n)\n</code></pre> <p>Plugins activate automatically when camera reaches <code>Ready</code> state.</p>"},{"location":"guides/plugins/#qr-scanner-plugin","title":"QR Scanner Plugin","text":""},{"location":"guides/plugins/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(\"io.github.kashif-mehmood-km:qr_scanner_plugin:0.2.0\")\n}\n</code></pre>"},{"location":"guides/plugins/#usage","title":"Usage","text":"<pre><code>@Composable\nfun QRScannerScreen() {\n    val permissions = providePermissions()\n    val stateHolder = rememberCameraKState(\n        permissions = permissions,\n        plugins = listOf(\n            rememberQRScannerPlugin()\n        )\n    )\n\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    val qrCodes by stateHolder.qrCodeFlow.collectAsStateWithLifecycle(initial = emptyList())\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                // Display scanned QR codes\n                if (qrCodes.isNotEmpty()) {\n                    Card(\n                        modifier = Modifier\n                            .align(Alignment.BottomCenter)\n                            .padding(16.dp)\n                    ) {\n                        Column(modifier = Modifier.padding(16.dp)) {\n                            Text(\"QR Code Detected\", style = MaterialTheme.typography.titleMedium)\n                            Spacer(modifier = Modifier.height(8.dp))\n                            Text(qrCodes.last(), style = MaterialTheme.typography.bodyMedium)\n                        }\n                    }\n                }\n            }\n\n            is CameraKState.Error -&gt; Text(\"Camera error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre> <p>Features: - Scans QR codes and barcodes automatically - Results exposed via <code>qrCodeFlow</code> - No manual frame processing needed</p>"},{"location":"guides/plugins/#ocr-plugin","title":"OCR Plugin","text":""},{"location":"guides/plugins/#installation_1","title":"Installation","text":"<pre><code>dependencies {\n    implementation(\"io.github.kashif-mehmood-km:ocr_plugin:0.2.0\")\n}\n</code></pre>"},{"location":"guides/plugins/#usage_1","title":"Usage","text":"<pre><code>@Composable\nfun OCRScannerScreen() {\n    val permissions = providePermissions()\n    val stateHolder = rememberCameraKState(\n        permissions = permissions,\n        plugins = listOf(\n            rememberOcrPlugin()\n        )\n    )\n\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    val recognizedText by stateHolder.recognizedTextFlow.collectAsStateWithLifecycle(initial = \"\")\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                // Display recognized text\n                if (recognizedText.isNotEmpty()) {\n                    Card(\n                        modifier = Modifier\n                            .align(Alignment.TopCenter)\n                            .padding(16.dp)\n                    ) {\n                        Column(modifier = Modifier.padding(16.dp)) {\n                            Text(\"Recognized Text\", style = MaterialTheme.typography.titleMedium)\n                            Spacer(modifier = Modifier.height(8.dp))\n                            Text(recognizedText, style = MaterialTheme.typography.bodyMedium)\n                        }\n                    }\n                }\n            }\n\n            is CameraKState.Error -&gt; Text(\"Camera error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre> <p>Features: - Recognizes text in real-time - Results exposed via <code>recognizedTextFlow</code> - Supports multiple languages</p>"},{"location":"guides/plugins/#image-saver-plugin","title":"Image Saver Plugin","text":""},{"location":"guides/plugins/#installation_2","title":"Installation","text":"<pre><code>dependencies {\n    implementation(\"io.github.kashif-mehmood-km:image_saver_plugin:0.2.0\")\n}\n</code></pre>"},{"location":"guides/plugins/#usage_2","title":"Usage","text":"<pre><code>val stateHolder = rememberCameraKState(\n    permissions = permissions,\n    plugins = listOf(\n        rememberImageSaverPlugin(\n            config = ImageSaverConfig(\n                isAutoSave = true,  // Auto-save every capture\n                directory = Directory.PICTURES\n            )\n        )\n    )\n)\n</code></pre> <p>Features: - Auto-saves captured images - Configurable save location - Optional image processing before save</p>"},{"location":"guides/plugins/#combine-multiple-plugins","title":"Combine Multiple Plugins","text":"<p>Use multiple plugins simultaneously:</p> <pre><code>@Composable\nfun MultiPluginCamera() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(\n        permissions = permissions,\n        plugins = listOf(\n            rememberQRScannerPlugin(),\n            rememberOcrPlugin(),\n            rememberImageSaverPlugin(config = ImageSaverConfig(isAutoSave = true))\n        )\n    )\n\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    val qrCodes by stateHolder.qrCodeFlow.collectAsStateWithLifecycle(initial = emptyList())\n    val recognizedText by stateHolder.recognizedTextFlow.collectAsStateWithLifecycle(initial = \"\")\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                Column(\n                    modifier = Modifier\n                        .align(Alignment.TopStart)\n                        .padding(16.dp)\n                ) {\n                    // QR codes\n                    if (qrCodes.isNotEmpty()) {\n                        Card {\n                            Text(\"QR: ${qrCodes.last()}\", modifier = Modifier.padding(8.dp))\n                        }\n                    }\n\n                    Spacer(modifier = Modifier.height(8.dp))\n\n                    // OCR text\n                    if (recognizedText.isNotEmpty()) {\n                        Card {\n                            Text(\"Text: $recognizedText\", modifier = Modifier.padding(8.dp))\n                        }\n                    }\n                }\n\n                // Capture button (auto-saved by plugin)\n                FloatingActionButton(\n                    onClick = {\n                        scope.launch {\n                            controller.takePictureToFile()\n                        }\n                    },\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(32.dp)\n                ) {\n                    Icon(Icons.Default.CameraAlt, \"Capture\")\n                }\n            }\n\n            is CameraKState.Error -&gt; Text(\"Camera error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/plugins/#plugin-lifecycle","title":"Plugin Lifecycle","text":"<p>Plugins follow camera lifecycle:</p> <ol> <li>Attach \u2014 Plugin added to state holder</li> <li>Auto-Activate \u2014 Plugin starts when camera reaches <code>Ready</code> state</li> <li>Processing \u2014 Plugin processes frames/events</li> <li>Cleanup \u2014 Plugin stops when camera is disposed</li> </ol> <p>No manual activation needed \u2014 plugins activate automatically.</p>"},{"location":"guides/plugins/#custom-plugin-development","title":"Custom Plugin Development","text":"<p>Create your own plugins by implementing <code>CameraKPlugin</code>:</p> <pre><code>class CustomPlugin : CameraKPlugin {\n    override val pluginName = \"CustomPlugin\"\n\n    override fun onAttach(stateHolder: CameraKStateHolder) {\n        // Initialize plugin\n        stateHolder.pluginScope.launch {\n            // Wait for camera ready\n            stateHolder.cameraState\n                .filterIsInstance&lt;CameraKState.Ready&gt;()\n                .first()\n\n            // Get controller and start processing\n            val controller = stateHolder.getReadyCameraController() ?: return@launch\n            controller.addImageCaptureListener { imageData -&gt;\n                // Process captured images\n                processImage(imageData)\n            }\n        }\n    }\n\n    override fun onDetach() {\n        // Cleanup resources\n    }\n\n    private fun processImage(imageData: ByteArray) {\n        // Custom processing logic\n    }\n}\n\n// Usage\n@Composable\nfun rememberCustomPlugin(): CustomPlugin {\n    return remember { CustomPlugin() }\n}\n</code></pre>"},{"location":"guides/plugins/#plugin-api-reference","title":"Plugin API Reference","text":""},{"location":"guides/plugins/#camerakplugin-interface","title":"CameraKPlugin Interface","text":"<pre><code>interface CameraKPlugin {\n    val pluginName: String\n\n    fun onAttach(stateHolder: CameraKStateHolder)\n    fun onDetach()\n}\n</code></pre>"},{"location":"guides/plugins/#camerakstateholder-plugin-methods","title":"CameraKStateHolder Plugin Methods","text":"<pre><code>class CameraKStateHolder {\n    // Wait for camera ready and get controller\n    suspend fun getReadyCameraController(): CameraController?\n\n    // Scope for plugin operations (auto-cancelled on cleanup)\n    val pluginScope: CoroutineScope\n\n    // Observe camera state\n    val cameraState: StateFlow&lt;CameraKState&gt;\n}\n</code></pre>"},{"location":"guides/plugins/#performance-tips","title":"Performance Tips","text":"<ol> <li>Limit plugins \u2014 Each plugin adds processing overhead</li> <li>Throttle frame processing \u2014 Don't process every frame</li> <li>Use background threads \u2014 Keep processing off main thread</li> <li>Cleanup properly \u2014 Unregister listeners in <code>onDetach</code></li> </ol>"},{"location":"guides/plugins/#common-issues","title":"Common Issues","text":""},{"location":"guides/plugins/#plugin-not-activating","title":"Plugin Not Activating","text":"<p>Cause: Plugin added after camera already ready.</p> <p>Solution: Add plugins during <code>rememberCameraKState</code> initialization.</p>"},{"location":"guides/plugins/#multiple-qrocr-results","title":"Multiple QR/OCR Results","text":"<p>Cause: Plugins scan continuously.</p> <p>Solution: Debounce results or take first result only:</p> <pre><code>val qrCodes by stateHolder.qrCodeFlow\n    .debounce(500)  // Wait 500ms between results\n    .collectAsStateWithLifecycle(initial = emptyList())\n</code></pre>"},{"location":"guides/plugins/#performance-degradation","title":"Performance Degradation","text":"<p>Cause: Too many plugins or heavy processing.</p> <p>Solution: Reduce plugin count or optimize processing logic.</p>"},{"location":"guides/plugins/#next-steps","title":"Next Steps","text":"<ul> <li>CameraKStateHolder API \u2014 State management details</li> <li>Camera Capture \u2014 Capture photos with plugins</li> <li>Configuration \u2014 Configure plugin behavior</li> </ul>"},{"location":"guides/zoom-control/","title":"Zoom Control","text":"<p>Implement digital zoom with pinch gestures.</p>"},{"location":"guides/zoom-control/#basic-zoom-control","title":"Basic Zoom Control","text":"<pre><code>// Set zoom level\ncontroller.setZoom(2.0f)  // 2x zoom\n\n// Get current zoom\nval currentZoom = controller.getZoom()  // returns Float\n\n// Get maximum zoom\nval maxZoom = controller.getMaxZoom()  // e.g., 10.0\n</code></pre> <p>Zoom range: <code>1.0</code> (no zoom) to <code>maxZoom</code> (device-dependent, typically 4-10x)</p>"},{"location":"guides/zoom-control/#pinch-to-zoom-implementation","title":"Pinch-to-Zoom Implementation","text":"<pre><code>@Composable\nfun CameraWithPinchZoom() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    var currentZoom by remember { mutableStateOf(1.0f) }\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n                val maxZoom = remember { controller.getMaxZoom() }\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier\n                        .fillMaxSize()\n                        .pointerInput(Unit) {\n                            detectTransformGestures { _, _, zoom, _ -&gt;\n                                // Calculate new zoom level\n                                val newZoom = (currentZoom * zoom).coerceIn(1f, maxZoom)\n                                currentZoom = newZoom\n                                controller.setZoom(newZoom)\n                            }\n                        }\n                )\n\n                // Zoom indicator\n                Text(\n                    text = \"${String.format(\"%.1f\", currentZoom)}x\",\n                    modifier = Modifier\n                        .align(Alignment.TopCenter)\n                        .padding(16.dp)\n                        .background(Color.Black.copy(alpha = 0.5f), RoundedCornerShape(16.dp))\n                        .padding(horizontal = 16.dp, vertical = 8.dp),\n                    color = Color.White,\n                    fontSize = 16.sp\n                )\n\n                // Capture button\n                FloatingActionButton(\n                    onClick = {\n                        scope.launch {\n                            controller.takePictureToFile()\n                        }\n                    },\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(32.dp)\n                ) {\n                    Icon(Icons.Default.CameraAlt, \"Capture\")\n                }\n            }\n\n            is CameraKState.Error -&gt; Text(\"Camera error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/zoom-control/#zoom-slider","title":"Zoom Slider","text":"<p>Alternative to pinch gesture:</p> <pre><code>@Composable\nfun CameraWithZoomSlider() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    var zoomLevel by remember { mutableStateOf(1.0f) }\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n                val maxZoom = remember { controller.getMaxZoom() }\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                // Zoom slider\n                Column(\n                    modifier = Modifier\n                        .align(Alignment.CenterEnd)\n                        .padding(16.dp)\n                        .background(Color.Black.copy(alpha = 0.5f), RoundedCornerShape(24.dp))\n                        .padding(16.dp)\n                ) {\n                    Text(\n                        text = \"${String.format(\"%.1f\", zoomLevel)}x\",\n                        color = Color.White,\n                        fontSize = 14.sp,\n                        modifier = Modifier.align(Alignment.CenterHorizontally)\n                    )\n\n                    Spacer(modifier = Modifier.height(8.dp))\n\n                    Slider(\n                        value = zoomLevel,\n                        onValueChange = { newZoom -&gt;\n                            zoomLevel = newZoom\n                            controller.setZoom(newZoom)\n                        },\n                        valueRange = 1f..maxZoom,\n                        modifier = Modifier\n                            .height(200.dp)\n                            .graphicsLayer {\n                                rotationZ = 270f  // Vertical slider\n                                transformOrigin = TransformOrigin(0f, 0f)\n                            }\n                    )\n                }\n\n                // Capture button\n                FloatingActionButton(\n                    onClick = {\n                        scope.launch {\n                            controller.takePictureToFile()\n                        }\n                    },\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(32.dp)\n                ) {\n                    Icon(Icons.Default.CameraAlt, \"Capture\")\n                }\n            }\n\n            is CameraKState.Error -&gt; Text(\"Camera error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/zoom-control/#quick-zoom-buttons","title":"Quick Zoom Buttons","text":"<p>Preset zoom levels:</p> <pre><code>@Composable\nfun CameraWithQuickZoom() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    var currentZoom by remember { mutableStateOf(1.0f) }\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n                val maxZoom = remember { controller.getMaxZoom() }\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier.fillMaxSize()\n                )\n\n                // Quick zoom buttons\n                Row(\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(bottom = 100.dp)\n                        .background(Color.Black.copy(alpha = 0.5f), RoundedCornerShape(24.dp))\n                        .padding(8.dp),\n                    horizontalArrangement = Arrangement.spacedBy(8.dp)\n                ) {\n                    listOf(1.0f, 2.0f, 5.0f).forEach { zoom -&gt;\n                        if (zoom &lt;= maxZoom) {\n                            Button(\n                                onClick = {\n                                    currentZoom = zoom\n                                    controller.setZoom(zoom)\n                                },\n                                colors = ButtonDefaults.buttonColors(\n                                    containerColor = if (currentZoom == zoom) \n                                        Color.White else Color.Gray\n                                )\n                            ) {\n                                Text(\n                                    text = \"${zoom.toInt()}x\",\n                                    color = if (currentZoom == zoom) Color.Black else Color.White\n                                )\n                            }\n                        }\n                    }\n                }\n\n                // Capture button\n                FloatingActionButton(\n                    onClick = {\n                        scope.launch {\n                            controller.takePictureToFile()\n                        }\n                    },\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(32.dp)\n                ) {\n                    Icon(Icons.Default.CameraAlt, \"Capture\")\n                }\n            }\n\n            is CameraKState.Error -&gt; Text(\"Camera error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/zoom-control/#smooth-zoom-animation","title":"Smooth Zoom Animation","text":"<p>Animate zoom changes:</p> <pre><code>@Composable\nfun CameraWithSmoothZoom() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    var targetZoom by remember { mutableStateOf(1.0f) }\n    val animatedZoom by animateFloatAsState(\n        targetValue = targetZoom,\n        animationSpec = tween(durationMillis = 300, easing = FastOutSlowInEasing)\n    )\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n                val maxZoom = remember { controller.getMaxZoom() }\n\n                // Apply animated zoom\n                LaunchedEffect(animatedZoom) {\n                    controller.setZoom(animatedZoom)\n                }\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier\n                        .fillMaxSize()\n                        .pointerInput(Unit) {\n                            detectTransformGestures { _, _, zoom, _ -&gt;\n                                val newZoom = (targetZoom * zoom).coerceIn(1f, maxZoom)\n                                targetZoom = newZoom\n                            }\n                        }\n                )\n\n                // Zoom indicator with animation\n                Text(\n                    text = \"${String.format(\"%.1f\", animatedZoom)}x\",\n                    modifier = Modifier\n                        .align(Alignment.TopCenter)\n                        .padding(16.dp)\n                        .background(Color.Black.copy(alpha = 0.5f), RoundedCornerShape(16.dp))\n                        .padding(horizontal = 16.dp, vertical = 8.dp),\n                    color = Color.White\n                )\n            }\n\n            is CameraKState.Error -&gt; Text(\"Camera error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/zoom-control/#double-tap-zoom","title":"Double-Tap Zoom","text":"<p>Zoom in/out on double tap:</p> <pre><code>@Composable\nfun CameraWithDoubleTapZoom() {\n    val permissions = providePermissions()\n    val scope = rememberCoroutineScope()\n    val stateHolder = rememberCameraKState(permissions = permissions)\n    val cameraState by stateHolder.cameraState.collectAsStateWithLifecycle()\n    var isZoomedIn by remember { mutableStateOf(false) }\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        when (cameraState) {\n            is CameraKState.Ready -&gt; {\n                val controller = (cameraState as CameraKState.Ready).controller\n\n                CameraPreviewComposable(\n                    controller = controller,\n                    modifier = Modifier\n                        .fillMaxSize()\n                        .pointerInput(Unit) {\n                            detectTapGestures(\n                                onDoubleTap = {\n                                    isZoomedIn = !isZoomedIn\n                                    val newZoom = if (isZoomedIn) 2.0f else 1.0f\n                                    controller.setZoom(newZoom)\n                                }\n                            )\n                        }\n                )\n\n                // Hint\n                if (controller.getZoom() == 1.0f) {\n                    Text(\n                        text = \"Double tap to zoom\",\n                        modifier = Modifier\n                            .align(Alignment.BottomCenter)\n                            .padding(bottom = 100.dp)\n                            .background(Color.Black.copy(alpha = 0.5f), RoundedCornerShape(16.dp))\n                            .padding(horizontal = 16.dp, vertical = 8.dp),\n                        color = Color.White\n                    )\n                }\n            }\n\n            is CameraKState.Error -&gt; Text(\"Camera error\")\n            CameraKState.Initializing -&gt; CircularProgressIndicator()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/zoom-control/#zoom-limits","title":"Zoom Limits","text":"<pre><code>val maxZoom = controller.getMaxZoom()\n\n// Constrain zoom to valid range\nfun setZoomSafely(zoom: Float) {\n    val clampedZoom = zoom.coerceIn(1f, maxZoom)\n    controller.setZoom(clampedZoom)\n}\n</code></pre> <p>Typical max zoom values: - Budget Android: 4x-8x - Flagship Android: 10x-30x (digital + optical) - iPhone: 5x-15x (varies by model) - Desktop webcam: 1x-4x</p>"},{"location":"guides/zoom-control/#ios-optical-vs-digital-zoom","title":"iOS: Optical vs Digital Zoom","text":"<p>On iOS, combine hardware camera switching with digital zoom:</p> <pre><code>// Configure for telephoto (2x optical)\nval stateHolder = rememberCameraKState(\n    permissions = permissions,\n    cameraConfiguration = {\n        setCameraDeviceType(CameraDeviceType.TELEPHOTO)\n    }\n)\n\n// Then apply digital zoom on top\ncontroller.setZoom(2.0f)  // Total 4x zoom (2x optical + 2x digital)\n</code></pre> <p>iOS camera types: - <code>CameraDeviceType.ULTRA_WIDE</code> \u2014 0.5x zoom - <code>CameraDeviceType.WIDE_ANGLE</code> \u2014 1x zoom (default) - <code>CameraDeviceType.TELEPHOTO</code> \u2014 2x-3x zoom</p>"},{"location":"guides/zoom-control/#performance-tips","title":"Performance Tips","text":"<ol> <li>Avoid rapid zoom changes \u2014 Debounce gesture input</li> <li>Use integer zoom levels \u2014 1x, 2x, 5x perform better than 1.37x</li> <li>Reset zoom when switching cameras \u2014 Front/back may have different limits</li> <li>Test on real devices \u2014 Emulators have limited zoom support</li> </ol>"},{"location":"guides/zoom-control/#common-issues","title":"Common Issues","text":""},{"location":"guides/zoom-control/#zoom-resets-when-switching-cameras","title":"Zoom Resets When Switching Cameras","text":"<p>Cause: Each camera has independent zoom state.</p> <p>Solution: Store and reapply zoom after switch:</p> <pre><code>val savedZoom = controller.getZoom()\ncontroller.toggleCameraLens()\ndelay(100)  // Wait for camera switch\ncontroller.setZoom(savedZoom.coerceIn(1f, controller.getMaxZoom()))\n</code></pre>"},{"location":"guides/zoom-control/#zoom-doesnt-work-on-front-camera","title":"Zoom Doesn't Work on Front Camera","text":"<p>Cause: Some front cameras don't support zoom.</p> <p>Solution: Check and disable zoom UI:</p> <pre><code>val maxZoom = controller.getMaxZoom()\nif (maxZoom &lt;= 1.0f) {\n    // No zoom available, hide zoom controls\n}\n</code></pre>"},{"location":"guides/zoom-control/#pinch-gesture-conflicts-with-scrolling","title":"Pinch Gesture Conflicts with Scrolling","text":"<p>Cause: Parent scrollable container intercepts gestures.</p> <p>Solution: Use <code>Modifier.pointerInput</code> on camera preview only, not parent.</p>"},{"location":"guides/zoom-control/#next-steps","title":"Next Steps","text":"<ul> <li>Camera Switching \u2014 Switch between front/back cameras</li> <li>Flash and Torch \u2014 Control lighting</li> <li>Camera Capture \u2014 Capture photos at current zoom</li> </ul>"}]}